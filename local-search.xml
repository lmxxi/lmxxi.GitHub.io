<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/2022/05/01/SPI/"/>
    <url>/2022/05/01/SPI/</url>
    
    <content type="html"><![CDATA[<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><h3 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h3><p>在面向对象编程中，一般都是基于接口编程，在实现一个具体实例时，就需要指明具体的实现类，一旦需要换一种实现方式，就需要修改代码。为了实现模块装配时不用动态指明具体实现类，就需要一种<strong>为接口寻找服务实现</strong>的机制，SPI就是这样一种机制，核心思想是<strong>解耦</strong>。<br>SPI将服务接口和服务实现分离，实现服务调用方和服务提供方的解耦，能够提升程序的可扩展性和可维护性，修改和替换服务的实现都不需要修改调用方。<br>（跟SpringBoot的自动装配思想很像）</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li>调用者定义一个接口</li><li>服务提供者提供接口的一个具体实现，在其jar包的META-INF&#x2F;servies目录下创建一个以<mark>接口全限定名</mark>命名的文件，文件内容为<mark>实现类的全限定类名</mark></li><li>将接口实现类的jar包放在主程序的classpath中</li><li>主程序通过ServiceLoader.load(接口名.class)从自己和jar包中的META-INF&#x2F;services目录下找到对应的文件，并读取其中的全限定类名，通过反射构建实现类对象实例，保存到provider列表中。</li></ol><p>SPI降低了服务调用方和服务提供方的耦合度，假如某个需求变更了，只需要更换jar包即可更改实现，而不用对调用方进行修改。</p><h3 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h3><p><strong>SPI：</strong> </p><ol><li><mark>接口位于调用者的包里</mark>  </li><li>概念上更依赖调用方</li><li>实现位于独立的包中</li></ol><p><strong>API：</strong>  </p><ol><li><mark>接口位于实现方的包里</mark>  </li><li>概念上更接近实现方  </li><li>实现和接口在一个包里</li></ol><h3 id="SPI有哪些缺点"><a href="#SPI有哪些缺点" class="headerlink" title="SPI有哪些缺点"></a>SPI有哪些缺点</h3><ol><li>遍历加载所有实现类，效率较低</li><li>并发情况下，多个ServiceLoader同时load会有并发问题</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a><br><a href="https://zhuanlan.zhihu.com/p/376142459">https://zhuanlan.zhihu.com/p/376142459</a><br><a href="https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176">https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2022/04/29/%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/04/29/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p><strong>Throwable</strong>是所有错误与异常的超类。<br>　<strong>Error：</strong> 程序无法处理的错误。<br>　<strong>Exception：</strong> 程序可以捕捉并处理的错误，分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。<br>　<strong>RuntimeException及其子类</strong>统称为<strong>非受检查异常</strong>，常见的有：  </p><ol><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误)</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>SecurityException （安全错误比如权限不够）</li></ol><p>　　</p><p>　其他异常都属于<strong>受检查异常</strong>，常见的有：</p><ol><li>IO 相关的异常</li><li>ClassNotFoundException </li><li>SQLException</li></ol><h3 id="finally中的代码一定会运行吗"><a href="#finally中的代码一定会运行吗" class="headerlink" title="finally中的代码一定会运行吗"></a>finally中的代码一定会运行吗</h3><p>不一定。<br>如果执行finally之前虚拟机终止，或者线程死亡都不会执行finally</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/04/28/%E9%9B%86%E5%90%88/"/>
    <url>/2022/04/28/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/04/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/04/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？优缺点？"><a href="#什么是反射？优缺点？" class="headerlink" title="什么是反射？优缺点？"></a>什么是反射？优缺点？</h3><p>反射就是将类中的各个成分（<strong>成员变量、方法、构造方法</strong>）映射成一个个<strong>对象</strong>，动态对其操作。<br><strong>优点：</strong> 让代码更灵活，可以在运行时分析操作类。<br><strong>缺点：</strong> 增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><h3 id="如何获取class对象"><a href="#如何获取class对象" class="headerlink" title="如何获取class对象"></a>如何获取class对象</h3><ol><li>类名.class()</li><li>对象.getclass()</li><li>Class.forName(全限定类名)</li></ol><h3 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h3><ol><li>动态代理</li><li>注解</li></ol><h3 id="介绍一下代理模式"><a href="#介绍一下代理模式" class="headerlink" title="介绍一下代理模式"></a>介绍一下代理模式</h3><p><strong>静态代理：</strong>   </p><ol><li>定义一个接口及其实现类  </li><li>创建一个代理类并实现这个接口</li><li>将目标类注入代理类，并在代理类中调用目标方法并增强</li></ol><p><strong>动态代理：</strong>分为<strong>JDK动态代理</strong>和<strong>Cglib动态代理</strong><br>　<strong>JDK动态代理：</strong>   <mark>只能代理实现了接口的类。</mark><br>　代理步骤：  </p><ol><li>定义一个接口及其实现类  </li><li>自定义<strong>InvocationHandler</strong>接口并重写**invoke()**方法，在invoke()中会通过反射调用被代理类的方法并自定义一些处理逻辑  </li><li>通过Proxy类创建代理对象</li></ol><p>当我们通过Proxy类创建的代理对象调用一个方法时，这个方法就会转发到InvocationHandler接口的实现类的invoke()方法。</p><p>　<strong>CGLIB动态代理：</strong> <mark>通过生成一个被代理类的子类拦截方法，故不能代理final修饰的类。</mark><br>　代理步骤：  </p><ol><li>定义一个类  </li><li>自定义<strong>MethodInterceptor</strong>接口并重写**intercept()**方法，通过反射调用被代理类方法，并自定义处理逻辑</li><li>通过<strong>Enhancer类</strong>的**create()**方法创建代理对象</li></ol><h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol><li><strong>灵活性：</strong> <strong>静态代理</strong>中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。<strong>动态代理</strong>更加灵活，不需要为每一个目标类都生成一个代理类，有相同处理需求的目标类可以复用同一个代理类。</li><li><strong>JVM 层面：</strong> <strong>静态代理</strong>在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 而<strong>动态代理</strong>是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h3 id="为什么JDK动态代理只能基于接口实现，不能基于继承"><a href="#为什么JDK动态代理只能基于接口实现，不能基于继承" class="headerlink" title="为什么JDK动态代理只能基于接口实现，不能基于继承"></a>为什么JDK动态代理只能基于接口实现，不能基于继承</h3><p>JDK动态代理在创建代理对象时，默认继承了Proxy类，由于Java只能单继承，所以只能通过接口实现</p><h3 id="为什么需要实现接口"><a href="#为什么需要实现接口" class="headerlink" title="为什么需要实现接口"></a>为什么需要实现接口</h3><p>因为代理对象只有实现同一个接口才能获得同一个方法并重新实现，实现代理的功能，否则代理对象都没有目标方法。</p><h3 id="static方法和private方法可以被动态代理吗"><a href="#static方法和private方法可以被动态代理吗" class="headerlink" title="static方法和private方法可以被动态代理吗"></a>static方法和private方法可以被动态代理吗</h3><p>不可以。<br>无论JDK动态代理还是CGLIB代理，都需要重写或实现方法的。<br>在JDK代理中，需要实现接口中的方法实现代理，而接口中的static方法不允许子类重写，所以<strong>编译</strong>时就会报错。<br>而CGLIB代理中，需要重写目标类方法来调用intercept()方法，通过用目标类引用指向代理对象实现多态，实际调用代理类方法。但<strong>静态方法不支持多态</strong>，最终调用的还是目标类的静态方法，即<strong>通过CGLIB代理static方法不会报错但不走代理</strong>。</p><p>private方法不能被外部访问，故不能被动态代理。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/04/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/04/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型起到一个模板的作用。对于只有数据类型不同的代码，如果没有泛型，就要针对每种类型重载一个方法，通过泛型，可以直接复用同一个方法。<br>泛型的类型在使用时指定，由编译器进行类型检查。</p><h3 id="泛型使用方式"><a href="#泛型使用方式" class="headerlink" title="泛型使用方式"></a>泛型使用方式</h3><p>泛型类、泛型接口、泛型方法</p><h3 id="如何理解java中的泛型是伪泛型"><a href="#如何理解java中的泛型是伪泛型" class="headerlink" title="如何理解java中的泛型是伪泛型"></a>如何理解java中的泛型是伪泛型</h3><p>伪泛型指语法上支持泛型，但在编译阶段会进行<strong>类型擦除</strong>，将所有的泛型替换为具体类型。<br>类型擦除原则：如果类型参数没有限制，则替换为<strong>Object</strong>，存在上界时，如&lt;T extends Number&gt;则替换成<strong>Number</strong>，存在下界时如&lt;T super Number&gt;，则替换成<strong>Object</strong>。</p><h3 id="如何理解泛型的编译器检查"><a href="#如何理解泛型的编译器检查" class="headerlink" title="如何理解泛型的编译器检查"></a>如何理解泛型的编译器检查</h3><p>编译器会<strong>先检查类型</strong>，再进行<strong>类型擦除</strong>，再<strong>编译</strong>。<br>类型检查针对<strong>引用</strong>，而无关它真正引用的对象。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>        list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="如何理解泛型的多态？泛型的桥方法？"><a href="#如何理解泛型的多态？泛型的桥方法？" class="headerlink" title="如何理解泛型的多态？泛型的桥方法？"></a>如何理解泛型的多态？泛型的桥方法？</h3><p>当子类继承泛型父类时，可能只希望继承某一个具体类型的父类，于是重写了父类对应具体类型参数的父类方法，但由于<mark>类型擦除</mark>，父类再编译阶段会替换成Object类，父类方法类型也变成Object类型，导致子类方法和父类方法不一样，重写变成了重载。<br>针对这个问题，JVM会为子类自动生成一个<mark>桥方法</mark>，桥方法和父类方法一致，<mark>在桥方法内部，会调用子类中自己重写的方法，也就是说，实际覆盖父类的是桥方法。</mark><br>（注：子类中的桥方法和自己重写的方法同时存在，如果只有方法类型不同，是无法辨别的，该如何处理呢？针对这个问题，我们自己写的代码是无法通过编译的，但编译器为了实现泛型的多态允许自己这样做，然后交给虚拟机区分，虚拟机可以根据参数类型和返回类型确定一个方法。）</p><h3 id="为什么基本类型不能作为泛型"><a href="#为什么基本类型不能作为泛型" class="headerlink" title="为什么基本类型不能作为泛型"></a>为什么基本类型不能作为泛型</h3><p>类型擦除后原始类型会变为Object，但Object不能存基本类型</p><h3 id="为什么泛型不能实例化"><a href="#为什么泛型不能实例化" class="headerlink" title="为什么泛型不能实例化"></a>为什么泛型不能实例化</h3><p>因为在编译器没办法确定泛型参数化类型，也就找不到具体的类字节码文件，无法完成类加载。<br>（如果非要用泛型实例化可以通过反射实现）</p><h3 id="泛型类可以定义泛型类型的静态变量吗"><a href="#泛型类可以定义泛型类型的静态变量吗" class="headerlink" title="泛型类可以定义泛型类型的静态变量吗"></a>泛型类可以定义泛型类型的静态变量吗</h3><p>不可以。因为泛型类型要在定义对象时指定，而静态变量不需要使用对象来调用，创建静态变量时无法确定其类型。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/04/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）<br>浮点数：float（4字节）、double（8字节）<br>字符型：char（2字节）<br>布尔型：boolean（1字节）<br><mark>（注：使用long要在数字后面加上后缀L，否则当作int处理）</mark>  </p><h3 id="基本类型和包装类区别"><a href="#基本类型和包装类区别" class="headerlink" title="基本类型和包装类区别"></a>基本类型和包装类区别</h3><ol><li><strong>成员变量</strong>包装类不赋值默认是null，基本类型不赋值默认是0  </li><li>包装类可以用作泛型，基本类型不可以  </li><li>作为<strong>局部变量</strong>的基本类型存在栈里，作为<strong>成员变量</strong>的基本类型存在堆里，包装类存在堆里（<strong>几乎</strong>所有对象都存在堆里）</li><li>基本类型占用空间更小</li></ol><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p> Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False<br> 如果没有超出范围，则复用已有缓存对象，否则创建新对象</p><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：将基本类型用它们对应的引用类型包装起来；<br>　　Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>拆箱：将包装类型转换为基本数据类型；<br>　　int n &#x3D; i 等价于 int n &#x3D; i.intValue()</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p><strong>重载：</strong> 存在与<strong>同一个类</strong>中，要求<mark>方法名<strong>相同</strong>，参数类型、个数、顺序<strong>至少有一个不同</strong></mark>。<mark>（注：仅有方法返回类型不同不算重载）</mark><br><strong>重写：</strong> 针对<strong>父类和子类</strong>，子类对父类中的方法重新实现。要求：  </p><ol><li>子类方法的<strong>访问权限</strong><mark>大于等于</mark>父类  </li><li>子类方法的<strong>返回类型</strong><mark>小于等于</mark>父类</li><li>子类方法的<strong>抛出异常</strong><mark>小于等于</mark>父类</li></ol><h3 id="接口和抽象类的共同点和区别"><a href="#接口和抽象类的共同点和区别" class="headerlink" title="接口和抽象类的共同点和区别"></a>接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong>  </p><ol><li>都不能被实例化  </li><li>都可以有抽象方法  </li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ol><p><strong>区别：</strong>  </p><ol><li>接口主要对类的行为进行约束，实现了某个接口就拥有了其行为；抽象类更强调所属关系  </li><li><strong>一个类可以实现多个接口，但只能继承一个类</strong>  </li><li>接口的成员变量只能是<strong>public static final</strong>类型，不能被修改且有初始值；抽象类的变量不限制，并且可在子类中重新定义和赋值</li></ol><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>浅拷贝：</strong> 在堆上创建一个新的对象，但如果对象的属性是引用类型，浅拷贝直接复制其引用地址，即<mark>拷贝对象和原对象共用同一个内部对象</mark><br><strong>深拷贝：</strong> 连同内部对象一同复制，即<mark>拷贝对象创建一个新的内部对象</mark></p><h3 id="Object类有哪些方法"><a href="#Object类有哪些方法" class="headerlink" title="Object类有哪些方法"></a>Object类有哪些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashcode的作用"><a href="#hashcode的作用" class="headerlink" title="hashcode的作用"></a>hashcode的作用</h3><p>快速确定对象在哈希表中的索引位置</p><h3 id="为什么重写equals-必须重写hashcode"><a href="#为什么重写equals-必须重写hashcode" class="headerlink" title="为什么重写equals()必须重写hashcode()"></a>为什么重写equals()必须重写hashcode()</h3><p>因为两个相等的对象，其hashcode也必须相等<br>如果重写了equals()而没有重写hashcode()：<br><strong>使用HashSet或HashMap：</strong> 插入对象时，会先判断是否有相同的hashcode，如果hashcode相同再用equals()比较两个对象是否相等，如果没有重写hashcode()，两个相同对象的hashcode不同，认为集合内没有重复对象，直接插入，此时就会导致集合内存在两个相同的对象</p><h3 id="String如何实现不可变"><a href="#String如何实现不可变" class="headerlink" title="String如何实现不可变"></a>String如何实现不可变</h3><ol><li>保存字符串的数组用<strong>private</strong>和<strong>final</strong>修饰，并且没有提供修改字符数组的方法  </li><li>String类用<strong>final</strong>修饰，不可继承，避免了子类破坏不可变性</li></ol><h3 id="字符串拼接用’-’的原理"><a href="#字符串拼接用’-’的原理" class="headerlink" title="字符串拼接用’+’的原理"></a>字符串拼接用’+’的原理</h3><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <strong>StringBuilder</strong> 调用 <strong>append()</strong> 方法实现的，拼接完成之后调用 <strong>toString()</strong> 得到一个 String 对象。<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>对于 String str3 &#x3D; “str” + “ing”; 编译器会给你优化成 String str3 &#x3D; “string”; 称为<strong>常量折叠</strong>。</p><h3 id="a-x3D-a-b-和-a-x3D-b有什么区别"><a href="#a-x3D-a-b-和-a-x3D-b有什么区别" class="headerlink" title="a&#x3D;a+b 和 a+&#x3D;b有什么区别"></a>a&#x3D;a+b 和 a+&#x3D;b有什么区别</h3><p>+&#x3D;会隐式的将计算结果转换为持有结果的类型。<br>在使用byte、short、int相加的时候，首先会将数据提升到int类型，然后再计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b; <span class="hljs-comment">// error : cannot convert from int to byte</span><br>b += a; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><mark>a+b操作会将a和b提升到int，所以将int类型赋值给byte就会报错</mark></p><h3 id="char变量能不能存汉字"><a href="#char变量能不能存汉字" class="headerlink" title="char变量能不能存汉字"></a>char变量能不能存汉字</h3><p>可以。Java中char采用Unicode编码集，占2个字节，一个汉字也是2字节，所以可以存储。</p><h3 id="静态方法和静态属性可以被继承和重写吗"><a href="#静态方法和静态属性可以被继承和重写吗" class="headerlink" title="静态方法和静态属性可以被继承和重写吗"></a>静态方法和静态属性可以被继承和重写吗</h3><p>可以被继承。在子类中会被 <strong>“隐藏”</strong>。<br>static方法不能被重写，即便写法上是重写，但是并不具备<strong>多态</strong>的含义。static方法是属于类的，不属于任何对象，即便具体对象所声明的引用对象调用了static方法，实际执行的也是<strong>引用对象类型对应的类里的方法</strong>。<br>因为多态是通过父类引用指向子类对象，调用重写方法时子类方法有更高的优先级，所以调用子类方法，但隐藏方法和属性不参与比较。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
