<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2022/08/13/Linux/"/>
    <url>/2022/08/13/Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p>在 Linux 的文件系统中，保存在磁盘分区中的文件都分配一个编号，称为索引节点号(Inode Index)。<br><strong>硬链接：</strong> A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。<br>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，<strong>文件真正删除的条件是与之相关的所有硬连接文件均被删除。</strong><br><strong>软链接：</strong> 软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 <strong>A 的数据块中存放的只是 B 的路径名</strong>（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。<br>使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。</p><h3 id="如何查看某个端口号被哪个进程占用"><a href="#如何查看某个端口号被哪个进程占用" class="headerlink" title="如何查看某个端口号被哪个进程占用"></a>如何查看某个端口号被哪个进程占用</h3><ul><li>lsof -i:端口号  </li><li>netstat -anp | grep pid<br>查看所有端口：netstat -ntlp</li></ul><h3 id="如何查看文件和目录大小"><a href="#如何查看文件和目录大小" class="headerlink" title="如何查看文件和目录大小"></a>如何查看文件和目录大小</h3><p>du -sh</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>ls: 列出当前目录下文件<br>cd: 切换目录<br>cp: 复制文件到指定目录<br>find: 查找文件<br>mkdir: 创建文件夹<br>mv: 移动文件到指定目录<br>rm: 删除文件或目录<br>cat: 查看文件<br>more: 分页查看文件<br>less: 分页查看文件，可以前后翻页、跳转、查找<br>tail: 显示文件最后几条记录<br>du: 查看磁盘空间使用情况<br>df: 查看文件系统磁盘使用情况<br>top: 实时监控当前系统正在执行的进程的相关信息<br>free: 查看系统内存情况<br>lsof: 用于查看你进程开打的文件，打开文件的进程，进程打开的端口<br>ps aux: 显示所有进程信息<br>ps -ef:显示所有进程信息<br>sed: 替换文件中的字符</p><h3 id="cpu内存占用率很高如何排查"><a href="#cpu内存占用率很高如何排查" class="headerlink" title="cpu内存占用率很高如何排查"></a>cpu内存占用率很高如何排查</h3><ol><li>通过<strong>top</strong>命令查看各个进程使用cpu情况，找到cpu使用率最高的进程  </li><li>通过 <strong>top -Hp 进程id</strong>查看该进程下各个线程的cpu使用情况</li><li>使用<strong>jstack 线程id</strong>命令查看当前进程的堆栈状态</li><li>根据之前获得的cpu占用率较高的线程pid，将该pid转成16进制的值，在thread dump中每个线程都有一个nid，找到对应的nid即可；隔段时间再执行一次jstack命令获取thread dump，区分两份dump是否有差别，如果发现一直在执行某个方法，就可以检查对应的代码是否有问题。</li></ol><h3 id="内存占用过高如何排查"><a href="#内存占用过高如何排查" class="headerlink" title="内存占用过高如何排查"></a>内存占用过高如何排查</h3><ol><li>通过<strong>top</strong>命令定位到内存占用过高的进程id</li><li>使用<strong>jstat -gccause pid</strong>命令查看该进程的gc情况</li><li>如果发现gc非常频繁，通过<strong>jmap</strong>命令查询进程实体类内存占用情况，检查哪个类的创建了过多的实体对象及内存泄漏情况</li><li>如果没有上述问题，通过<strong>jmap -heap</strong>查看堆的各个分代的使用情况，如果发生频繁gc是因为堆的分代大小设置有问题，可以修改各个分代大小</li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2022/08/11/JUC/"/>
    <url>/2022/08/11/JUC/</url>
    
    <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="JUC框架包含哪些部分"><a href="#JUC框架包含哪些部分" class="headerlink" title="JUC框架包含哪些部分"></a>JUC框架包含哪些部分</h3><ol><li>Lock框架和工具类：AQS、LockSupport、ReentrantLock、ReadWriteLock、工具类（Semaphore、CountdownLatch、CylicBarrier)</li><li>并发集合: ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、BlockingQueue</li><li>原子类</li><li>线程池</li></ol><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="对Unsafe类的理解"><a href="#对Unsafe类的理解" class="headerlink" title="对Unsafe类的理解"></a>对Unsafe类的理解</h3><ul><li>Unsafe类，主要提供一些用于底层操作的方法，如内存访问、内存管理等，使Java拥有直接操作内存的功能，同时也增加了不安全。</li><li>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类。</li></ul><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>通过 <strong>Atomic::cmpxchg</strong> 来实现比较和替换操作。如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p><h3 id="原子类有哪些"><a href="#原子类有哪些" class="headerlink" title="原子类有哪些"></a>原子类有哪些</h3><ol><li>基本类型原子类：</li></ol><ul><li>AtomicInteger：整型原子类 </li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><ol start="2"><li>数组类型原子类：</li></ol><ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><ol start="3"><li>引用类型原子类：</li></ol><ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。标记是否被更改。</li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><ol start="4"><li>对象的属性修改类型原子类</li></ol><ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul><h3 id="原子类原理"><a href="#原子类原理" class="headerlink" title="原子类原理"></a>原子类原理</h3><p>CAS + volatile</p><h2 id="LockSupport类"><a href="#LockSupport类" class="headerlink" title="LockSupport类"></a>LockSupport类</h2><h3 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h3><ul><li><strong>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</strong></li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传；</li></ul><h3 id="Object-wait-和Condition-await-的区别"><a href="#Object-wait-和Condition-await-的区别" class="headerlink" title="Object.wait()和Condition.await()的区别"></a>Object.wait()和Condition.await()的区别</h3><p>Condition.await()底层是调用<strong>LockSupport.park()<strong>来实现阻塞当前线程的。它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”</strong>释放锁</strong>，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p><h3 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h3><ul><li>都不会释放当前线程占有的锁资源；</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来，LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li><li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出，LockSupport.park()方法不需要捕获中断异常；</li></ul><h3 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h3><ul><li>wait()释放锁，park()不释放锁；</li><li><strong>wait()需要在synchronized或lock()中执行</strong>，避免多线程并发下notify()在wait()前执行，<strong>park()不需要，unpark()在park()前运行也可以；</strong></li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出，LockSupport.park()不需要捕获中断异常；</li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS的核心思想是，如果请求的资源空闲，就将当前申请资源的线程设为工作线程，并将共享资源设为锁定状态。如果被请求的资源被锁定，就需要一套等待机制及线程唤醒锁分配机制。这个机制通过CLH队列实现。<br>CLH队列是一个双向链表。<br>AQS使用volatile修饰的变量state表示锁的状态，通过CAS对其进行修改。</p><h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><ul><li>独占<br> <strong>ReentrantLock</strong>:支持公平锁和非公平锁。</li><li>共享<br> <strong>Semaphore、CountDownLatch、 CyclicBarrier</strong></li></ul><p><strong>ReentrantReadWriteLock</strong>是两种锁的组合。</p><h3 id="AQS核心方法"><a href="#AQS核心方法" class="headerlink" title="AQS核心方法"></a>AQS核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空并且头节点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头节点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquire()和release()使用模板方法，由实现类实现以下具体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><h3 id="AQS底层为什么设计成双向链表"><a href="#AQS底层为什么设计成双向链表" class="headerlink" title="AQS底层为什么设计成双向链表"></a>AQS底层为什么设计成双向链表</h3><ul><li>队列中节点尝试获取锁的条件是前置节点是头节点</li><li>唤醒线程时要从后向前遍历</li><li>判断一个节点是否要被阻塞要看前置节点的状态是否为SIGNAL</li></ul><p>所以设置成双向链表会更方便获取到前置节点的状态</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h3><ul><li>Synchronized是关键字，ReentrantLock是JUC包下的工具类；</li><li>Synchronized只支持非公平锁，ReentranLock支持公平锁和非公平锁；</li><li>Synchronized和ReentranLock都是可重入锁</li><li>ReentrantLock可以和Condition一起使用，实现选择性通知，更加灵活；</li><li>ReentrantLock提供了等待可中断机制，通过 lock.lockInterruptibly()可以使正在等待的线程放弃等待</li></ul><h3 id="ReentrantLock的内部实现"><a href="#ReentrantLock的内部实现" class="headerlink" title="ReentrantLock的内部实现"></a>ReentrantLock的内部实现</h3><p>ReentrantLock有三个内部类，<strong>Sync、FairSync、NonFairSync</strong>，Sync类继承了AQS抽象类，FairSync和NonFairSync继承了Sync类。<br>ReentrantLock可以选择公平锁和非公平锁（默认非公平锁）。<br>非公平锁和公平锁区别：</p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</li></ul><h3 id="ReentrantLock加锁解锁过程"><a href="#ReentrantLock加锁解锁过程" class="headerlink" title="ReentrantLock加锁解锁过程"></a>ReentrantLock加锁解锁过程</h3><p>加锁解锁流程如下：</p><img src="/2022/08/11/JUC/%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81.png" class="" title="加锁解锁"><p>加锁：</p><ul><li><p>通过ReentrantLock的加锁方法Lock进行加锁操作。</p></li><li><p>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</p></li><li><p>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</p></li><li><p>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</p></li></ul><p>解锁：</p><ul><li><p>通过ReentrantLock的解锁方法Unlock进行解锁。</p></li><li><p>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</p></li><li><p>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</p></li><li><p>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</p></li></ul><h3 id="加锁失败如何处理"><a href="#加锁失败如何处理" class="headerlink" title="加锁失败如何处理"></a>加锁失败如何处理</h3><p>执行AQS的 <strong>addwaiter()</strong> 方法，将当前的线程构建成一个节点，通过CAS将其设置成双向队列的尾节点（只是CAS将其前向指针指向当前尾节点）。<br>加入队列后，执行 <strong>acquireQueued()</strong> 方法，通过自旋等待获取锁，出队列条件是：<strong>前一个节点是头节点，且当前节点获取锁成功。</strong><br>为了防止因死循环导致CPU资源被浪费，如果获取锁失败或前一个节点不是头节点，则通过shouldParkAfterFailedAcquire()方法判断是否要将当前线程挂起（<strong>被阻塞条件：前驱节点的waitStatus为-1</strong>），判断流程如下：</p><img src="/2022/08/11/JUC/shouldparkafterfailedacquire.png" class=""><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>在release()方法中调用tryRelease()释放锁成功后，通过<strong>unparkSuccessor()</strong> 方法唤醒后继节点。如果当前节点的下个节点是null或者下个节点被cancelled，就<strong>从后向前</strong>找到第一个waitStatus&lt;0的节点并唤醒。<br>从后往前找是因为入队是非原子操作（入队时先将前向指针指向当前尾节点，然后CAS将新加入节点设置成尾节点，但此时pred.next&#x3D;node可能还没执行），此时如果从前往后遍历就是断的。同时产生CANCELLED节点也会断开next指针，可能无法遍历到所有节点，所以从后往前遍历。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基础</title>
    <link href="/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><img src="/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="线程生命周期"><h3 id="创建线程有几种方式"><a href="#创建线程有几种方式" class="headerlink" title="创建线程有几种方式"></a>创建线程有几种方式</h3><ol><li>继承<strong>Thread类</strong>，并重写 <strong>run()</strong> 方法，创建子类对象，执行 <strong>start()</strong> 方法。</li><li>实现<strong>Runnable接口</strong>，并实现 <strong>run()</strong> 方法，创建实现类对象并传入<strong>Thread类</strong>的构造函数，执行 <strong>start()</strong> 方法。</li><li>实现<strong>Callable接口</strong>， 并实现 <strong>call()</strong> 方法,创建实现类对象并传入<strong>FutureTask</strong>的构造方法，再将FutureTask对象传入Thread构造方法中，执行start()方法，并通过FutureTask的 <strong>get()</strong> 方法获取结果。</li></ol><h3 id="什么是线程安全？如何实现线程安全？"><a href="#什么是线程安全？如何实现线程安全？" class="headerlink" title="什么是线程安全？如何实现线程安全？"></a>什么是线程安全？如何实现线程安全？</h3><p><strong>线程安全：</strong> 多个线程访问一个对象时，每个线程都能获得正确的结果。<br><strong>实现线程安全：</strong> </p><ol><li>互斥同步：通过<strong>synchronize</strong>、<strong>Reentrantlock</strong>等互斥锁</li><li>非互斥同步：通过CAS</li><li>Threadlocal</li><li>其他：工具类（如：信号量、CountdownLatch、CylierBatch等）、wait&#x2F;notify、join等通信机制、volatile等</li></ol><h3 id="start-方法是否可以重复执行"><a href="#start-方法是否可以重复执行" class="headerlink" title="start()方法是否可以重复执行"></a>start()方法是否可以重复执行</h3><p>不可以。线程内部会维持一个状态变量，调用一次start()后这个变量会随之改变，如果执行start()时变量不为0会抛出异常。</p><h3 id="可不可以不执行start-方法，直接执行run-方法"><a href="#可不可以不执行start-方法，直接执行run-方法" class="headerlink" title="可不可以不执行start()方法，直接执行run()方法"></a>可不可以不执行start()方法，直接执行run()方法</h3><p>不可以。调用start()方法会让线程启动并进入就绪状态，然后自动执行run()方法，直接执行run()方法会把run()方法当作一个普通方法执行。</p><h3 id="知道哪些锁"><a href="#知道哪些锁" class="headerlink" title="知道哪些锁"></a>知道哪些锁</h3><ol><li><strong>乐观锁</strong>和<strong>悲观锁</strong><br>悲观锁：认为使用数据时一定有别的线程同时修改数据，所以在获取数据前要先加锁。Synchronized和Lock的实现类<br>乐观锁：认为使用数据时没有其他线程修改数据，所以不会加锁，只是在更新数据时判断有无其他线程对数据进行修改，如果没有则更新数据。CAS</li><li><strong>自旋锁</strong>和<strong>适应性自旋锁</strong><br>自旋锁：如果同步资源的使用时间很短，没必要令等待线程进入阻塞状态（阻塞和唤醒需要耗费处理器时间），通过让线程自旋等待数据。原理是CAS<br>适应性自旋锁：根据之前的自旋次数和锁的持有状态自动调整自旋次数，避免自旋时间多长浪费cpu资源</li><li><strong>公平锁</strong>和<strong>非公平锁</strong><br>公平锁：如果前面有线程在申请资源，则排队等待锁的释放。<br>非公平锁：无论前面有没有线程等待，直接尝试获取锁，如果获取失败则排队等待。可能导致某些线程一直拿不到锁。</li><li><strong>可重入锁</strong>和<strong>不可重入锁</strong><br>可重入锁：同一个线程如果已经获得了外部方法的锁，再进入内层方法会自动获得锁（前提是锁是同一个对象），避免死循环</li><li><strong>排他锁</strong>和<strong>共享锁</strong><br>读读共享、其他都互斥</li></ol><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>参考链接：<a href="https://javaguide.cn/java/concurrent/jmm.html#%E4%BB%8E-cpu-%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%B4%E8%B5%B7">https://javaguide.cn/java/concurrent/jmm.html#%E4%BB%8E-cpu-%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%B4%E8%B5%B7</a></p><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>JMM是为了屏蔽不同操作系统内存模型差异提出的一组<strong>规范</strong>。JMM<strong>抽象了线程和内存之间的关系</strong>，同时<strong>规定了从源代码到CPU执行指令这个过程中要遵守的规则</strong>，目的是简化多线程编程。JMM主要围绕<strong>原子性、可见性、有序性</strong>。<br>JMM规定所有的变量都存在<strong>主内存</strong>中，同时每个线程都有一个<strong>本地内存</strong>存放共享变量的<strong>副本</strong>，所有修改都在本地内存中进行，每个线程只能访问自己的本地内存。</p><h3 id="什么是happens-before原则"><a href="#什么是happens-before原则" class="headerlink" title="什么是happens-before原则"></a>什么是happens-before原则</h3><p>happens-before原则描述两个操作之间的内存可见性。它是JMM底层规则的抽象总结，便于程序员理解，通过happens-before原则可以简单地判断线程安全。<br>定义：</p><ol><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li><li>如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li></ol><p>happens-before原则：</p><ol><li>程序顺序规则 ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li><li>解锁规则 ：对一个锁的解锁操作 Happens-Before于后续对这个锁的加锁操作；</li><li>volatile 变量规则 ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。</li><li>线程启动规则：Thread 对象的 start（）方法 happens-before 于此线程的每一个动作。</li><li>传递规则 ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li>线程终结规则：线程中的所有操作都先行发生于对此线程的终止检测；</li><li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li></ol><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="synchronized如何使用"><a href="#synchronized如何使用" class="headerlink" title="synchronized如何使用"></a>synchronized如何使用</h3><ol><li>修饰静态方法：获得类的锁</li><li>修饰普通方法：获得对象的锁</li><li>修饰代码块：在括号里指定获得锁的对象</li></ol><h3 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h3><ol><li>修饰代码块：通过在字节码中对应代码块的前后加上<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，使锁的计数器加1或减1，同一时刻只有一个线程可以获得monitor监视器的持有权（每个对象有一个内置的monitor对象）。</li><li>修饰方法：在对应方法的字节码上加入<strong>ACC_SYNCHRONIZED</strong>标记，标明同步方法。</li></ol><h3 id="JDK1-6-之后对synchronized作了哪些优化"><a href="#JDK1-6-之后对synchronized作了哪些优化" class="headerlink" title="JDK1.6 之后对synchronized作了哪些优化"></a>JDK1.6 之后对synchronized作了哪些优化</h3><p><strong>锁粗化：</strong> 减少不必要的连续的锁，将连续的锁变为一个范围更大的锁<br><strong>锁消除：</strong> 通过<strong>逃逸分析</strong>判断如果对象不会被其他线程方法，则取消锁<br><strong>适应性自旋：</strong> 通过之前自旋次数和获得锁的情况调整自旋次数<br><strong>锁升级：</strong></p><ol><li>无锁  </li><li>偏向锁：对于获得一个线程，获得了某个对象的锁后，再访问该对象就不用重新获得锁了，如果有两个线程竞争锁，则升级为轻量级锁。对象头由<strong>线程ID</strong>、<strong>epoch</strong>、<strong>对象分代年龄</strong>、<strong>是否是偏向锁</strong>、<strong>锁标志位</strong>构成。</li><li>轻量级锁：使用CAS获取锁，没获取到锁的线程自旋等待，如果自旋次数超过阈值，则升级为重量级锁。在<strong>栈</strong>里加入一个<strong>锁记录</strong>，存放之前的对象头中的Markword内容，并将对象头中的Markword替换为<strong>指向栈中锁记录的指针</strong>。</li><li>重量级锁： 竞争锁失败直接进入阻塞状态。对象头中存放指向锁监视器的指针。</li></ol><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a>volatile作用</h3><ol><li>防止指令重排序，保证<strong>有序性</strong>  </li><li>保证变量<strong>可见性</strong></li></ol><h3 id="什么是指令重排序"><a href="#什么是指令重排序" class="headerlink" title="什么是指令重排序"></a>什么是指令重排序</h3><p>在执行程序时为了提高性能，编译器和处理器会对指令进行重排序。<br>编译重排序：在不改变单线程程序语义的条件下，调整指令顺序，提高效率。<br>处理器重排序：由于处理器并行执行指令出现指令的重排序</p><h3 id="as-if-serial原则"><a href="#as-if-serial原则" class="headerlink" title="as-if-serial原则"></a>as-if-serial原则</h3><p>无论怎么重排序，单线程程序的执行结果不能改变。</p><h3 id="防止指令重排序原理"><a href="#防止指令重排序原理" class="headerlink" title="防止指令重排序原理"></a>防止指令重排序原理</h3><p><strong>内存屏障。</strong> 内存屏障作用包括：1.禁止内存屏障前后的指令重排序；2.强制将变量写到主存，并使其他线程缓存中对应变量失效，强制到主存中读取。<br>写volatile变量时，JVM会在写之前插入<strong>storestore屏障</strong>，保证之前的写操作执行完毕，在写之后插入<strong>storeload屏障</strong>，保证写入对后面的读操作可见。<br>读volatile变量时，会在读后面插入<strong>loadload屏障</strong>和<strong>loadstore屏障</strong>，保证在后面的操作前已经读完。</p><h3 id="如何保证变量可见性"><a href="#如何保证变量可见性" class="headerlink" title="如何保证变量可见性"></a>如何保证变量可见性</h3><p>当写volatile变量时，在字节码前加上一个<strong>lock前缀</strong>（本质是内存屏障），将缓存数据写回主存，同时使其他cpu中该地址数据无效，其他线程读取变量时就需要到主存中读，这样读取到的就是最新值。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h3><ol><li>修饰类：声明该类不允许继承  </li><li>修饰方法：声明该方法不允许重写</li><li>修饰变量：变量初始化后不可改变</li><li>修饰参数：参数指向不可改变</li></ol><h3 id="final修饰的字段必须是编译期常量吗"><a href="#final修饰的字段必须是编译期常量吗" class="headerlink" title="final修饰的字段必须是编译期常量吗"></a>final修饰的字段必须是编译期常量吗</h3><p>不一定。只是初始化后不能再改变。</p><h3 id="final重排序规则"><a href="#final重排序规则" class="headerlink" title="final重排序规则"></a>final重排序规则</h3><p>基本数据类型：<br>　final写：禁止final写重排序到构造函数以外。<br>　final读：禁止初次读对象与读该对象的final成员变量重排序<br>引用数据类型：禁止　在构造函数对final修饰的成员域的写入　与　之后将这个被构造的对象赋值给引用变量　重排序</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/2022/05/01/SPI/"/>
    <url>/2022/05/01/SPI/</url>
    
    <content type="html"><![CDATA[<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><h3 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h3><p>在面向对象编程中，一般都是基于接口编程，在实现一个具体实例时，就需要指明具体的实现类，一旦需要换一种实现方式，就需要修改代码。为了实现模块装配时不用动态指明具体实现类，就需要一种<strong>为接口寻找服务实现</strong>的机制，SPI就是这样一种机制，核心思想是<strong>解耦</strong>。<br>SPI将服务接口和服务实现分离，实现服务调用方和服务提供方的解耦，能够提升程序的可扩展性和可维护性，修改和替换服务的实现都不需要修改调用方。<br>（跟SpringBoot的自动装配思想很像）</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li>调用者定义一个接口</li><li>服务提供者提供接口的一个具体实现，在其jar包的META-INF&#x2F;servies目录下创建一个以<mark>接口全限定名</mark>命名的文件，文件内容为<mark>实现类的全限定类名</mark></li><li>将接口实现类的jar包放在主程序的classpath中</li><li>主程序通过ServiceLoader.load(接口名.class)从自己和jar包中的META-INF&#x2F;services目录下找到对应的文件，并读取其中的全限定类名，通过反射构建实现类对象实例，保存到provider列表中。</li></ol><p>SPI降低了服务调用方和服务提供方的耦合度，假如某个需求变更了，只需要更换jar包即可更改实现，而不用对调用方进行修改。</p><h3 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h3><p><strong>SPI：</strong> </p><ol><li><mark>接口位于调用者的包里</mark>  </li><li>概念上更依赖调用方</li><li>实现位于独立的包中</li></ol><p><strong>API：</strong>  </p><ol><li><mark>接口位于实现方的包里</mark>  </li><li>概念上更接近实现方  </li><li>实现和接口在一个包里</li></ol><h3 id="SPI有哪些缺点"><a href="#SPI有哪些缺点" class="headerlink" title="SPI有哪些缺点"></a>SPI有哪些缺点</h3><ol><li>遍历加载所有实现类，效率较低</li><li>并发情况下，多个ServiceLoader同时load会有并发问题</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a><br><a href="https://zhuanlan.zhihu.com/p/376142459">https://zhuanlan.zhihu.com/p/376142459</a><br><a href="https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176">https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2022/04/29/%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/04/29/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p><strong>Throwable</strong>是所有错误与异常的超类。<br>　<strong>Error：</strong> 程序无法处理的错误。<br>　<strong>Exception：</strong> 程序可以捕捉并处理的错误，分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。<br>　<strong>RuntimeException及其子类</strong>统称为<strong>非受检查异常</strong>，常见的有：  </p><ol><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误)</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>SecurityException （安全错误比如权限不够）</li></ol><p>　　</p><p>　其他异常都属于<strong>受检查异常</strong>，常见的有：</p><ol><li>IO 相关的异常</li><li>ClassNotFoundException </li><li>SQLException</li></ol><h3 id="finally中的代码一定会运行吗"><a href="#finally中的代码一定会运行吗" class="headerlink" title="finally中的代码一定会运行吗"></a>finally中的代码一定会运行吗</h3><p>不一定。<br>如果执行finally之前虚拟机终止，或者线程死亡都不会执行finally</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/04/28/%E9%9B%86%E5%90%88/"/>
    <url>/2022/04/28/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><img src="/2022/04/28/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png" class="" title="集合框架">  <h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List有哪些集合类"><a href="#List有哪些集合类" class="headerlink" title="List有哪些集合类"></a>List有哪些集合类</h3><ol><li>ArrayList: Object[]数组</li><li>LinkedList: 双向链表</li><li>vector: Object[]数组，线程安全</li></ol><h3 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h3><ol><li><strong>底层数据结构：</strong> ArrayList底层是<strong>Object数组</strong>，LinkedList底层是<strong>双向链表</strong></li><li><strong>随机访问：</strong> ArrayList支持<strong>随机访问</strong>，LinkedList只能遍历</li><li><strong>插入删除：</strong> ArrayList插入删除受元素位置影响，如果在末尾插入元素，时间复杂度O(1)，如果在中间插入或删除，时间复杂度O(n-i)，因为后续元素要移位；LinkedList在头尾插入或删除时间复杂度都是O(1)，在指定位置插入删除时间复杂度是O(n)，因为要遍历到指定位置</li><li><strong>内存占用：</strong> ArrayList空间浪费体现在会在数组末尾预留一定空间；LinkedList体现在每个元素比ArrayList占据更多空间（维护节点信息）</li></ol><h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h3><p>每次添加元素时会比较添加后的size和容量capacity的大小，如果超出容量则自动扩容，创建一个新数组，大小为旧数组大小的<strong>大约1.5倍</strong>，将旧数组元素拷贝到新数组中。<br>为减少数组多次扩容带来的性能影响，可以通过<strong>ensureCapacity()方法</strong>手动指定扩容大小，一次扩容完毕，避免多次扩容。<br><mark>（注：以无参构造方法创建ArrayList时，实际分配的是一个空数组，当第一次添加元素时触发扩容，扩容到容量为10）</mark></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map有哪些集合类"><a href="#Map有哪些集合类" class="headerlink" title="Map有哪些集合类"></a>Map有哪些集合类</h3><ol><li>HashMap: 1.7 数组+链表，1.8 数组+链表+红黑树</li><li>TreeMap: 红黑树，支持按key排序</li><li>HashTable: 数组+链表，线程安全</li><li>LinkedHashMap: 双向链表+哈希表，实现LRU</li></ol><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ol><li><strong>线程安全：</strong> HashTable是<strong>线程安全</strong>的，HashMap线程不安全</li><li><strong>是否支持NULL数据：</strong> HashTable不支持NULL键和NULL值，HashMap支持，但NULL键最多有一个</li><li><strong>底层结构：</strong> HashTable底层是数组+链表，HashMap是数组+红黑树+链表</li><li><strong>扩容大小：</strong> HashTable容量默认初始大小是<strong>11</strong>，每次扩容大小是<strong>2n+1</strong>，HashMap容量默认初始大小是<strong>16</strong>，每次扩容大小是<strong>2n</strong>。如果指定初始大小，HashTable直接就是指定大小，HashMap会扩容为<strong>离其最近的2的n次幂大小</strong></li></ol><h3 id="HashMap底层结构"><a href="#HashMap底层结构" class="headerlink" title="HashMap底层结构"></a>HashMap底层结构</h3><p><strong>1.7：</strong> 数组+链表，通过<strong>头插法</strong>插入元素。<br><strong>1.8：</strong> 数组+链表+红黑树，通过<strong>尾插法</strong>插入元素，当链表长度大于阈值（默认为8），且当前数组的长度大于64（否则先扩容），就将链表转为红黑树，小于等于6就转回链表</p><h3 id="为什么链表转为红黑树的阈值是8"><a href="#为什么链表转为红黑树的阈值是8" class="headerlink" title="为什么链表转为红黑树的阈值是8"></a>为什么链表转为红黑树的阈值是8</h3><p>转成红黑树是为了提升查询效率，红黑树的查询时间复杂度是O(logn)。但红黑树节点要比Node节点占更多的内存，所以当链表长度比较短的时候，红黑树并不能带来特别大的性能提升，同时还占用了更多内存。<br>同时经过统计，通常情况下，链表长度能达到8的情况是非常少的，这种设置更多是为了防止用户自己实现了比较差的hash算法导致的链表过长。</p><h3 id="HashMap的长度为什么是2的n次幂"><a href="#HashMap的长度为什么是2的n次幂" class="headerlink" title="HashMap的长度为什么是2的n次幂"></a>HashMap的长度为什么是2的n次幂</h3><ol><li>当插入元素时，需要通过 <strong>hash % length</strong> 确定插入位置，如果长度是2的n次方，上述公式等价于 <strong>hash &amp; (length-1)</strong> ，使用&amp;运算更快  </li><li>数据迁移时判断更方便。当长度是2的n次方时，扩容时判断元素是否要迁移到新的桶中，只需要用元素的key的二进制值和旧容量作&amp;运算，然后判断高位是否是0，如果是0则留在当前桶中，否则迁移到新桶，新桶位置为<strong>当前位置+旧容量</strong>。</li></ol><h3 id="HashMap扩容原理"><a href="#HashMap扩容原理" class="headerlink" title="HashMap扩容原理"></a>HashMap扩容原理</h3><p>先通过几个if条件判断特殊情况：  </p><ol><li>如果当前容量大于0，则正常扩容</li><li>判断当前容量是否大于等于最大容量，如果大于，阈值设为Integer.MAX_VALUE</li><li>如果是第一次put，则按构造函数设置初始容量和阈值</li></ol><p>正式扩容：<br>用新的数组大小初始化数组，遍历数组，如果桶中只有一个元素，直接迁移；如果是红黑树，则拆分红黑树；如果是链表，将其拆分成两个链表，通过计算每个元素的 <strong>hash &amp; oldcap</strong>，判断其高位是0或1，分别插入到两个链表中，对于高位是0的元素，留在当前位置，高位是1的元素，迁移至 <strong>pos+oldcap</strong> 位置。</p><h3 id="HashMap为什么不安全"><a href="#HashMap为什么不安全" class="headerlink" title="HashMap为什么不安全"></a>HashMap为什么不安全</h3><p><strong>1.7：</strong> 并发扩容时存在<strong>死循环</strong>问题，并发put存在<strong>数据丢失</strong>问题<br><strong>死循环：</strong>  由于1.7插入使用<strong>头插法</strong>，可能出现线程A设置好当前节点和其next节点后挂起，线程B在这期间完成了迁移工作，此时之前的节点和next节点的位置发生了对调，线程A再以头插法迁移时，就会出现头尾相连，在get()时就会发生死循环。<br><strong>数据丢失：</strong> 1.7中put()方法先创建一个要插入的节点，在其构造函数中指定好next节点。假设线程A创建好节点后挂起，线程B创建新的节点并完成插入，线程A恢复后完成插入，就会覆盖线程B插入的节点，丢失数据。</p><p><strong>1.8：</strong> 并发put存在<strong>数据覆盖</strong>问题<br>1.8通过在数据迁移时构建两个链表并使用尾插法避免了1.7中的死循环问题（即便两个线程同时工作，无非第二个线程重复一遍第一个线程的工作），但仍存在并发put时数据丢失的问题。</p><h3 id="1-8中就不存在死循环了吗"><a href="#1-8中就不存在死循环了吗" class="headerlink" title="1.8中就不存在死循环了吗"></a>1.8中就不存在死循环了吗</h3><p>也会发生死循环。主要发生在<strong>链表转成树或对树进行操作时</strong>。<br>可能原因主要是多线程下操作同一对象时，对象的内部属性出现不一致。</p><h3 id="HashMap有几种遍历方式"><a href="#HashMap有几种遍历方式" class="headerlink" title="HashMap有几种遍历方式"></a>HashMap有几种遍历方式</h3><p>参考链接：<a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set有哪些集合类"><a href="#Set有哪些集合类" class="headerlink" title="Set有哪些集合类"></a>Set有哪些集合类</h3><ol><li>HashSet: 哈希表（对HashMap的封装）</li><li>LinkedHashSet： 双向链表+哈希表，保证插入有序性</li><li>TreeSet: 红黑树，支持排序</li></ol><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>先计算hashcode判断加入位置，如果没有重复元素则直接加入，如果有重复元素通过equals()判断是否真的相同，如果相同就拒绝加入。<br><mark>实际HashSet的add()方法只是简单调用了HashMap的put()方法，无论是否存在相同元素都会加入，只是会在add()方法的返回值处返回标记告诉我们插入前是否存在相同元素。</mark></p><h3 id="Comparable-和-Comparator的区别"><a href="#Comparable-和-Comparator的区别" class="headerlink" title="Comparable 和 Comparator的区别"></a>Comparable 和 Comparator的区别</h3><p>Comparable接口一般由对象去实现，重写其中的 <strong>compareTo()</strong> 方法，自定义对象的排序规则。<br>Comparator更接近于一个外部排序器，在集合的sort()中使用，在 <strong>compare()</strong> 方法中定义排序规则。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue有哪些集合类"><a href="#Queue有哪些集合类" class="headerlink" title="Queue有哪些集合类"></a>Queue有哪些集合类</h3><ol><li>PriorityQueue: 堆</li><li>LinkedList：实现了Queue和Deque</li><li>ArrayDeque: Deque的实现类，数组+双指针</li></ol><h3 id="LinkedList和ArrayDeque的区别"><a href="#LinkedList和ArrayDeque的区别" class="headerlink" title="LinkedList和ArrayDeque的区别"></a>LinkedList和ArrayDeque的区别</h3><ol><li>ArrayDeque底层是<strong>数组+双指针</strong>，LinkedList是链表</li><li>ArrayDeque不支持NULL数据，LinkedList支持</li></ol>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/04/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/04/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？优缺点？"><a href="#什么是反射？优缺点？" class="headerlink" title="什么是反射？优缺点？"></a>什么是反射？优缺点？</h3><p>反射就是将类中的各个成分（<strong>成员变量、方法、构造方法</strong>）映射成一个个<strong>对象</strong>，动态对其操作。<br><strong>优点：</strong> 让代码更灵活，可以在运行时分析操作类。<br><strong>缺点：</strong> 增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><h3 id="如何获取class对象"><a href="#如何获取class对象" class="headerlink" title="如何获取class对象"></a>如何获取class对象</h3><ol><li>类名.class()</li><li>对象.getclass()</li><li>Class.forName(全限定类名)</li></ol><h3 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h3><ol><li>动态代理</li><li>注解</li></ol><h3 id="介绍一下代理模式"><a href="#介绍一下代理模式" class="headerlink" title="介绍一下代理模式"></a>介绍一下代理模式</h3><p><strong>静态代理：</strong>   </p><ol><li>定义一个接口及其实现类  </li><li>创建一个代理类并实现这个接口</li><li>将目标类注入代理类，并在代理类中调用目标方法并增强</li></ol><p><strong>动态代理：</strong>分为<strong>JDK动态代理</strong>和<strong>Cglib动态代理</strong><br>　<strong>JDK动态代理：</strong>   <mark>只能代理实现了接口的类。</mark><br>　代理步骤：  </p><ol><li>定义一个接口及其实现类  </li><li>自定义<strong>InvocationHandler</strong>接口并重写**invoke()**方法，在invoke()中会通过反射调用被代理类的方法并自定义一些处理逻辑  </li><li>通过Proxy类创建代理对象</li></ol><p>当我们通过Proxy类创建的代理对象调用一个方法时，这个方法就会转发到InvocationHandler接口的实现类的invoke()方法。</p><p>　<strong>CGLIB动态代理：</strong> <mark>通过生成一个被代理类的子类拦截方法，故不能代理final修饰的类。</mark><br>　代理步骤：  </p><ol><li>定义一个类  </li><li>自定义<strong>MethodInterceptor</strong>接口并重写**intercept()**方法，通过反射调用被代理类方法，并自定义处理逻辑</li><li>通过<strong>Enhancer类</strong>的**create()**方法创建代理对象</li></ol><h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol><li><strong>灵活性：</strong> <strong>静态代理</strong>中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。<strong>动态代理</strong>更加灵活，不需要为每一个目标类都生成一个代理类，有相同处理需求的目标类可以复用同一个代理类。</li><li><strong>JVM 层面：</strong> <strong>静态代理</strong>在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 而<strong>动态代理</strong>是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h3 id="为什么JDK动态代理只能基于接口实现，不能基于继承"><a href="#为什么JDK动态代理只能基于接口实现，不能基于继承" class="headerlink" title="为什么JDK动态代理只能基于接口实现，不能基于继承"></a>为什么JDK动态代理只能基于接口实现，不能基于继承</h3><p>JDK动态代理在创建代理对象时，默认继承了Proxy类，由于Java只能单继承，所以只能通过接口实现</p><h3 id="为什么需要实现接口"><a href="#为什么需要实现接口" class="headerlink" title="为什么需要实现接口"></a>为什么需要实现接口</h3><p>因为代理对象只有实现同一个接口才能获得同一个方法并重新实现，实现代理的功能，否则代理对象都没有目标方法。</p><h3 id="static方法和private方法可以被动态代理吗"><a href="#static方法和private方法可以被动态代理吗" class="headerlink" title="static方法和private方法可以被动态代理吗"></a>static方法和private方法可以被动态代理吗</h3><p>不可以。<br>无论JDK动态代理还是CGLIB代理，都需要重写或实现方法的。<br>在JDK代理中，需要实现接口中的方法实现代理，而接口中的static方法不允许子类重写，所以<strong>编译</strong>时就会报错。<br>而CGLIB代理中，需要重写目标类方法来调用intercept()方法，通过用目标类引用指向代理对象实现多态，实际调用代理类方法。但<strong>静态方法不支持多态</strong>，最终调用的还是目标类的静态方法，即<strong>通过CGLIB代理static方法不会报错但不走代理</strong>。</p><p>private方法不能被外部访问，故不能被动态代理。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/04/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/04/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型起到一个模板的作用。对于只有数据类型不同的代码，如果没有泛型，就要针对每种类型重载一个方法，通过泛型，可以直接复用同一个方法。<br>泛型的类型在使用时指定，由编译器进行类型检查，提升安全性。</p><h3 id="泛型使用方式"><a href="#泛型使用方式" class="headerlink" title="泛型使用方式"></a>泛型使用方式</h3><p>泛型类、泛型接口、泛型方法</p><h3 id="如何理解java中的泛型是伪泛型"><a href="#如何理解java中的泛型是伪泛型" class="headerlink" title="如何理解java中的泛型是伪泛型"></a>如何理解java中的泛型是伪泛型</h3><p>伪泛型指语法上支持泛型，但在编译阶段会进行<strong>类型擦除</strong>，将所有的泛型替换为具体类型。<br>类型擦除原则：如果类型参数没有限制，则替换为<strong>Object</strong>，存在上界时，如&lt;T extends Number&gt;则替换成<strong>Number</strong>，存在下界时如&lt;T super Number&gt;，则替换成<strong>Object</strong>。</p><h3 id="如何理解泛型的编译器检查"><a href="#如何理解泛型的编译器检查" class="headerlink" title="如何理解泛型的编译器检查"></a>如何理解泛型的编译器检查</h3><p>编译器会<strong>先检查类型</strong>，再进行<strong>类型擦除</strong>，再<strong>编译</strong>。<br>类型检查针对<strong>引用</strong>，而无关它真正引用的对象。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>        list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="如何理解泛型的多态？泛型的桥方法？"><a href="#如何理解泛型的多态？泛型的桥方法？" class="headerlink" title="如何理解泛型的多态？泛型的桥方法？"></a>如何理解泛型的多态？泛型的桥方法？</h3><p>当子类继承泛型父类时，可能只希望继承某一个具体类型的父类，于是重写了父类对应具体类型参数的父类方法，但由于<mark>类型擦除</mark>，父类再编译阶段会替换成Object类，父类方法类型也变成Object类型，导致子类方法和父类方法不一样，重写变成了重载。<br>针对这个问题，JVM会为子类自动生成一个<mark>桥方法</mark>，桥方法和父类方法一致，<mark>在桥方法内部，会调用子类中自己重写的方法，也就是说，实际覆盖父类的是桥方法。</mark><br>（注：子类中的桥方法和自己重写的方法同时存在，如果只有方法类型不同，是无法辨别的，该如何处理呢？针对这个问题，我们自己写的代码是无法通过编译的，但编译器为了实现泛型的多态允许自己这样做，然后交给虚拟机区分，虚拟机可以根据参数类型和返回类型确定一个方法。）</p><h3 id="为什么基本类型不能作为泛型"><a href="#为什么基本类型不能作为泛型" class="headerlink" title="为什么基本类型不能作为泛型"></a>为什么基本类型不能作为泛型</h3><p>类型擦除后原始类型会变为Object，但Object不能存基本类型</p><h3 id="为什么泛型不能实例化"><a href="#为什么泛型不能实例化" class="headerlink" title="为什么泛型不能实例化"></a>为什么泛型不能实例化</h3><p>因为在编译器没办法确定泛型参数化类型，也就找不到具体的类字节码文件，无法完成类加载。<br>（如果非要用泛型实例化可以通过反射实现）</p><h3 id="泛型类可以定义泛型类型的静态变量吗"><a href="#泛型类可以定义泛型类型的静态变量吗" class="headerlink" title="泛型类可以定义泛型类型的静态变量吗"></a>泛型类可以定义泛型类型的静态变量吗</h3><p>不可以。因为泛型类型要在定义对象时指定，而静态变量不需要使用对象来调用，创建静态变量时无法确定其类型。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/04/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）<br>浮点数：float（4字节）、double（8字节）<br>字符型：char（2字节）<br>布尔型：boolean（1字节）<br><mark>（注：使用long要在数字后面加上后缀L，否则当作int处理）</mark>  </p><h3 id="基本类型和包装类区别"><a href="#基本类型和包装类区别" class="headerlink" title="基本类型和包装类区别"></a>基本类型和包装类区别</h3><ol><li><strong>成员变量</strong>包装类不赋值默认是null，基本类型不赋值默认是0  </li><li>包装类可以用作泛型，基本类型不可以  </li><li>作为<strong>局部变量</strong>的基本类型存在栈里，作为<strong>成员变量</strong>的基本类型存在堆里，包装类存在堆里（<strong>几乎</strong>所有对象都存在堆里）</li><li>基本类型占用空间更小</li></ol><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p> Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False<br> 如果没有超出范围，则复用已有缓存对象，否则创建新对象</p><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：将基本类型用它们对应的引用类型包装起来；<br>　　Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>拆箱：将包装类型转换为基本数据类型；<br>　　int n &#x3D; i 等价于 int n &#x3D; i.intValue()</p><h3 id="switch支持哪些类型"><a href="#switch支持哪些类型" class="headerlink" title="switch支持哪些类型"></a>switch支持哪些类型</h3><p>byte、short、int、char及各自包装类、枚举类型、String</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p><strong>重载：</strong> 存在与<strong>同一个类</strong>中，要求<mark>方法名<strong>相同</strong>，参数类型、个数、顺序<strong>至少有一个不同</strong></mark>。<mark>（注：仅有方法返回类型不同不算重载）</mark><br><strong>重写：</strong> 针对<strong>父类和子类</strong>，子类对父类中的方法重新实现。要求：  </p><ol><li>子类方法的<strong>访问权限</strong><mark>大于等于</mark>父类  </li><li>子类方法的<strong>返回类型</strong><mark>小于等于</mark>父类</li><li>子类方法的<strong>抛出异常</strong><mark>小于等于</mark>父类</li></ol><h3 id="接口和抽象类的共同点和区别"><a href="#接口和抽象类的共同点和区别" class="headerlink" title="接口和抽象类的共同点和区别"></a>接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong>  </p><ol><li>都不能被实例化  </li><li>都可以有抽象方法  </li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ol><p><strong>区别：</strong>  </p><ol><li>接口主要对类的行为进行约束，实现了某个接口就拥有了其行为；抽象类更强调所属关系  </li><li><strong>一个类可以实现多个接口，但只能继承一个类</strong>  </li><li>接口的成员变量只能是<strong>public static final</strong>类型，不能被修改且有初始值；抽象类的变量不限制，并且可在子类中重新定义和赋值</li></ol><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>浅拷贝：</strong> 在堆上创建一个新的对象，但如果对象的属性是引用类型，浅拷贝直接复制其引用地址，即<mark>拷贝对象和原对象共用同一个内部对象</mark><br><strong>深拷贝：</strong> 连同内部对象一同复制，即<mark>拷贝对象创建一个新的内部对象</mark></p><h3 id="Object类有哪些方法"><a href="#Object类有哪些方法" class="headerlink" title="Object类有哪些方法"></a>Object类有哪些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashcode的作用"><a href="#hashcode的作用" class="headerlink" title="hashcode的作用"></a>hashcode的作用</h3><p>快速确定对象在哈希表中的索引位置</p><h3 id="为什么重写equals-必须重写hashcode"><a href="#为什么重写equals-必须重写hashcode" class="headerlink" title="为什么重写equals()必须重写hashcode()"></a>为什么重写equals()必须重写hashcode()</h3><p>因为两个相等的对象，其hashcode也必须相等<br>如果重写了equals()而没有重写hashcode()：<br><strong>使用HashSet或HashMap：</strong> 插入对象时，会先判断是否有相同的hashcode，如果hashcode相同再用equals()比较两个对象是否相等，如果没有重写hashcode()，两个相同对象的hashcode不同，认为集合内没有重复对象，直接插入，此时就会导致集合内存在两个相同的对象</p><h3 id="String如何实现不可变"><a href="#String如何实现不可变" class="headerlink" title="String如何实现不可变"></a>String如何实现不可变</h3><ol><li>保存字符串的数组用<strong>private</strong>和<strong>final</strong>修饰，并且没有提供修改字符数组的方法  </li><li>String类用<strong>final</strong>修饰，不可继承，避免了子类破坏不可变性</li></ol><h3 id="字符串拼接用’-’的原理"><a href="#字符串拼接用’-’的原理" class="headerlink" title="字符串拼接用’+’的原理"></a>字符串拼接用’+’的原理</h3><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <strong>StringBuilder</strong> 调用 <strong>append()</strong> 方法实现的，拼接完成之后调用 <strong>toString()</strong> 得到一个 String 对象。<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>对于 String str3 &#x3D; “str” + “ing”; 编译器会给你优化成 String str3 &#x3D; “string”; 称为<strong>常量折叠</strong>。</p><h3 id="a-x3D-a-b-和-a-x3D-b有什么区别"><a href="#a-x3D-a-b-和-a-x3D-b有什么区别" class="headerlink" title="a&#x3D;a+b 和 a+&#x3D;b有什么区别"></a>a&#x3D;a+b 和 a+&#x3D;b有什么区别</h3><p>+&#x3D;会隐式的将计算结果转换为持有结果的类型。<br>在使用byte、short、int相加的时候，首先会将数据提升到int类型，然后再计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b; <span class="hljs-comment">// error : cannot convert from int to byte</span><br>b += a; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><mark>a+b操作会将a和b提升到int，所以将int类型赋值给byte就会报错</mark></p><h3 id="char变量能不能存汉字"><a href="#char变量能不能存汉字" class="headerlink" title="char变量能不能存汉字"></a>char变量能不能存汉字</h3><p>可以。Java中char采用Unicode编码集，占2个字节，一个汉字也是2字节，所以可以存储。</p><h3 id="静态方法和静态属性可以被继承和重写吗"><a href="#静态方法和静态属性可以被继承和重写吗" class="headerlink" title="静态方法和静态属性可以被继承和重写吗"></a>静态方法和静态属性可以被继承和重写吗</h3><p>可以被继承。在子类中会被 <strong>“隐藏”</strong>。<br>static方法不能被重写，即便写法上是重写，但是并不具备<strong>多态</strong>的含义。static方法是属于类的，不属于任何对象，即便具体对象所声明的引用对象调用了static方法，实际执行的也是<strong>引用对象类型对应的类里的方法</strong>。<br>因为多态是通过父类引用指向子类对象，调用重写方法时子类方法有更高的优先级，所以调用子类方法，但隐藏方法和属性不参与比较。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
