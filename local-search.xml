<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2022/08/29/MyBatis/"/>
    <url>/2022/08/29/MyBatis/</url>
    
    <content type="html"><![CDATA[<h3 id="JPA和MyBatis区别"><a href="#JPA和MyBatis区别" class="headerlink" title="JPA和MyBatis区别"></a>JPA和MyBatis区别</h3><p>JPA面向对象，简单的CURD可以直接通过封装好的方法实现，自定义查询可已通过@query注解编写SQL语句。缺点是阅读性较差。<br>MyBatis对SQL的编写非常灵活，可以完全自由控制。MyBatis的SQL语句写在XML中，与代码进行了分离，阅读非常直观，且修改SQL语句也不需要直接修改JAVA代码。</p><h3 id="和-区别"><a href="#和-区别" class="headerlink" title="#{}和${}区别"></a>#{}和${}区别</h3><p>#{}属于动态替换，#{}会被替换成?，之后替换为传入的参数。<br>$ 属于静态文本替换，直接替换为参数的字符串。<br>#可以防止sql注入，而${}不可以。<br>对于表名、group by、order by等必须用 $ 修饰，因为#{}会自动为传入的参数加上引号。</p><h3 id="mybatis的模糊查询"><a href="#mybatis的模糊查询" class="headerlink" title="mybatis的模糊查询"></a>mybatis的模糊查询</h3><ol><li>&#96;&#96;&#96; sql<br>SELECT * FROM user WHERE name LIKE #{name} <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    在传入数据上修改，例如：传入<span class="hljs-type">name</span>=&quot;%xxx%&quot;<br><span class="hljs-number">2.</span> 方式一需要手动添加%，不方便<br>   ``` <span class="hljs-keyword">sql</span><br>   <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%$&#123;name&#125;%&#x27;</span><br></code></pre></td></tr></table></figure>在sql语句中提前写好%，将#替换成$，因为#{}不能在字符串中。</li><li>方式二存在sql注入问题<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> concat(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)<br></code></pre></td></tr></table></figure> 利用concat连接，既解决sql注入又不用自己写%</li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2022/08/25/RabbitMQ/"/>
    <url>/2022/08/25/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h3><ul><li>Broker： 简单来说就是消息队列服务器实体</li><li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列</li><li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列</li><li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li><li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li><li>Producer： 消息生产者，就是投递消息的程序</li><li>Consumer： 消息消费者，就是接受消息的程序</li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li></ul><h3 id="交换器类型"><a href="#交换器类型" class="headerlink" title="交换器类型"></a>交换器类型</h3><ul><li><strong>direct</strong>:根据路由键完全匹配，发送到对应队列上</li><li><strong>fanout</strong>:广播</li><li><strong>topic</strong>:订阅模式，根据通配符匹配</li></ul><h3 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a>如何保证顺序消费</h3><p>产生乱序消费的原因有两个：</p><ol><li>一个Queue对应多个消费者，每个消费者处理消息速度不同，导致乱序</li><li>一个Queue对应一个消费者，但消费者内部用多线程处理消息，也会导致乱序</li></ol><p>保证消费顺序：<br>   一个Queue对应一个消费者，消费者内部用内部队列作排序，对关键字作哈希分配到对应队列中。</p><h3 id="消费失败如何处理"><a href="#消费失败如何处理" class="headerlink" title="消费失败如何处理"></a>消费失败如何处理</h3><ol><li>重试机制：消费失败重新进入队列等待被消费，超过重试次数的可以记录到数据库人工处理。</li><li>进入死信队列</li></ol><h3 id="如何解决消息重复消费"><a href="#如何解决消息重复消费" class="headerlink" title="如何解决消息重复消费"></a>如何解决消息重复消费</h3><p>重复消费的原因：消费成功后返回确认，但MQ没有收到确认，此时MQ不会删除消费成功的消息，一段时间后会重新给消费者投递消息，消费者收到重复消息。</p><p>解决方案：</p><ol><li>确保消费端只执行一次：可以为消息生成一个唯一标识，存在redis中，当收到消息时先检查redis里是否已经存在，如果是则直接拒绝消息。</li><li>确保消费端多次处理不会造成影响：比如对于新增任务，可以将消息的唯一标记设为主键，避免插入重复数据。</li></ol><h3 id="如何保证消息可靠性"><a href="#如何保证消息可靠性" class="headerlink" title="如何保证消息可靠性"></a>如何保证消息可靠性</h3><ul><li>对于生产者丢消息：发送确认机制，当消息成功送到交换机会发送一个确认，当消息<strong>没有</strong>成功从交换机到队列也会发送一个确认。解决：发送前记录数据，定期扫描重发</li><li>消息队列丢消息：RabbitMQ 宕机导致队列、队列中的消息丢失，相当于 RabbitMQ 弄丢消息。解决：开启消息队列的持久化（在持久化到磁盘过程中宕机仍可能丢失数据）。</li><li>消费者丢消息：自动确认导致没消费完就确认，解决：改为手动确认</li></ul><h3 id="RabbitMQ的持久化"><a href="#RabbitMQ的持久化" class="headerlink" title="RabbitMQ的持久化"></a>RabbitMQ的持久化</h3><p>包含3个部分：<br>exchange持久化<br>queue持久化<br>message持久化</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2022/08/21/spring/"/>
    <url>/2022/08/21/spring/</url>
    
    <content type="html"><![CDATA[<h3 id="依赖注入的方式和区别"><a href="#依赖注入的方式和区别" class="headerlink" title="依赖注入的方式和区别"></a>依赖注入的方式和区别</h3><ul><li><strong>属性注入</strong>：<ul><li>优点：简洁</li><li>缺点：使用属性注入的类只能在IOC容器中使用，因为该类没有提供该属性的 set方法或者相应的构造方法来完成该属性的初始化，无法脱离IOC容器new一个实例出来。</li></ul></li><li>setter注入<ul><li>优点：1.相比构造方法更简洁，某些可选属性可以不注入；2.类的属性可以在之后重新配置或注入</li><li>缺点：1.导致代码冗余，难以维护；2.依赖可能变化</li></ul></li><li>构造器注入<ul><li>优点：1.依赖不可变；2.依赖不为空：通过构造方法注入的时候，会自动检查注入的对象是否为空，如果为空，则注入失败；如果不为空，才会注入成功；3.完全初始化：保证注入的对象已经完全初始化了。</li><li>缺点：1.代码臃肿；2.对可选属性需要手动注入null；3.不利子类扩展和继承，因为子类要实现父类复杂的构造函数。<br>（注：对于全都使用构造方法注入的bean，无法自动解决循环依赖，如果发生循环依赖会直接报错）</li></ul></li></ul><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><h3 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h3><p>解决循环依赖有两个前提：</p><ul><li><strong>依赖的Bean必须是单例</strong></li><li><strong>依赖注入不能全是构造器注入</strong><br>必须是单例的原因：如果两个Bean都是原型模式的话，创建 A1 需要创建一个 B1，创建 B1 的时候要创建一个 A2，创建 A2 又要创建一个 B2，创建 B2 又要创建一个 A3……因为原型模式都需要创建新的对象，不能跟用以前的对象，所以只能是单例。<br>不能是构造器注入的原因：构造方法在实例化时调用，此时bean还没有实例化完成，三级缓存中还没有Bean（Bean在实例化后放入三级缓存），因此无法获得相应Bean。<br>（注：主bean用字段或Set方法注入，副Bean用构造器方法可以解决循环依赖）</li></ul><p>解决循环依赖依靠三级缓存，<br>一级缓存：存放初始化好的完整bean<br>二级缓存：存放完成实例化，但没有属性注入和初始化的bean<br>三级缓存：存储能建立这个 Bean 的一个工厂，通过工厂能获取这个 Bean，延迟化 Bean 的生成，工厂生成的 Bean 会塞入二级缓存</p><p>首先，获取单例Bean会先检查缓存中是否存在bean对象。如果不存在，则创建bean，将A实例化，并将其放入工厂添加到三级缓存中，然后对A进行属性注入，注入B时重复上述过程，注入A时，直接从三级缓存中获取到工厂中的对象，并放入二级缓存，接着B完成属性注入和初始化，放入一级缓存，然后回到A对象，将一级缓存中的B注入，A完成属性注入和初始化。</p><h3 id="为什么需要三级缓存？二级缓存不行吗？"><a href="#为什么需要三级缓存？二级缓存不行吗？" class="headerlink" title="为什么需要三级缓存？二级缓存不行吗？"></a>为什么需要三级缓存？二级缓存不行吗？</h3><p>一级缓存：保证对象是单例<br>二级缓存：存放从三级缓存的工厂中获得的对象<br>三级缓存：存放对象工厂</p><p>三级缓存为了延迟对象暴露，延迟AOP代理对象的生成。<br>当获取依赖的时候，如果依赖的Bean实现了AOP代理，那么我们希望获得的对象是代理对象。<br>当发生循环依赖时，B通过三级缓存中的A的工厂调用getObject()方法，会判断A是否实现了AOP代理，如果是则返回一个代理对象。<br>如果没有三级缓存，无论是否发生循环依赖，那么所有bean都要在实例化后生成代理对象，这与bean的生命周期不符（AOP代理对象正常是在初始化后生成）。而假如使用三级缓存后，只有判断在发生了循环依赖的时候才生成代理对象，否则这个三级缓存中的工厂根本不会被使用。</p><h3 id="没有二级缓存可以吗"><a href="#没有二级缓存可以吗" class="headerlink" title="没有二级缓存可以吗"></a>没有二级缓存可以吗</h3><p>不可以。如果没有二级缓存，每次调用三级缓存工厂对象的getobject()方法，都会产生一个新的对象，破坏了单例模式。</p><h3 id="Spring在创建Bean的时候，在哪里创建的AOP动态代理？"><a href="#Spring在创建Bean的时候，在哪里创建的AOP动态代理？" class="headerlink" title="Spring在创建Bean的时候，在哪里创建的AOP动态代理？"></a>Spring在创建Bean的时候，在哪里创建的AOP动态代理？</h3><p>如果没有循环依赖的话，在bean初始化完成后创建动态代理<br>如果有循环依赖，在bean实例化之后创建</p><h3 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h3><h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智力题</title>
    <link href="/2022/08/21/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <url>/2022/08/21/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="赛马"><a href="#赛马" class="headerlink" title="赛马"></a>赛马</h3><p><a href="https://www.jianshu.com/p/13d7191669ca">https://www.jianshu.com/p/13d7191669ca</a></p><h3 id="一个桶能存储5升水，一个桶能存储3升水，如何操作能量出4升水"><a href="#一个桶能存储5升水，一个桶能存储3升水，如何操作能量出4升水" class="headerlink" title="一个桶能存储5升水，一个桶能存储3升水，如何操作能量出4升水"></a>一个桶能存储5升水，一个桶能存储3升水，如何操作能量出4升水</h3><h3 id="两根质地不均匀的木头，从一端烧到另一端需要60分钟，如何操作能准确量出15分钟？"><a href="#两根质地不均匀的木头，从一端烧到另一端需要60分钟，如何操作能准确量出15分钟？" class="headerlink" title="两根质地不均匀的木头，从一端烧到另一端需要60分钟，如何操作能准确量出15分钟？"></a>两根质地不均匀的木头，从一端烧到另一端需要60分钟，如何操作能准确量出15分钟？</h3>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><h3 id="CSMA-x2F-CD协议作用于哪一层？如何工作的？如何降低碰撞几率？"><a href="#CSMA-x2F-CD协议作用于哪一层？如何工作的？如何降低碰撞几率？" class="headerlink" title="CSMA&#x2F;CD协议作用于哪一层？如何工作的？如何降低碰撞几率？"></a>CSMA&#x2F;CD协议作用于哪一层？如何工作的？如何降低碰撞几率？</h3><p>数据链路层。<br>CSMA&#x2F;CD 为带有冲突检测的载波侦听多路访问技术。载波侦听是指发送点在发送信息帧之前，必须听媒体是否处于空闲状态，多路访问既表示多个结点可以同时访问媒体，也表示一个结点发送的信息帧可以被多个结点所接收。<br>基本原理是：每个节点都共享网络传输信道，在每个站要发送数据之前，都会检测信道是否空闲，如果空闲则发送，否则就等待；在发送出信息后，则对冲突进行检测，当发现冲突时，则取消发送。<br>若信道忙碌，则等待一段时间至信道中的信息传输结束后再发送数据；若在上一段信息发送结束后，同时有两个或两个以上的节点都提出发送请求，则判定为冲突。若侦听到冲突，则立即停止发送数据，等待一段随机时间，再重新尝试。<br>其原理简单总结为：<strong>先听后发，边发边听，冲突停发，随机延迟后重发</strong></p><h3 id="ICMP作用"><a href="#ICMP作用" class="headerlink" title="ICMP作用"></a>ICMP作用</h3><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="SSL-x2F-TLS介于哪两层之间？对应用层透明吗？"><a href="#SSL-x2F-TLS介于哪两层之间？对应用层透明吗？" class="headerlink" title="SSL&#x2F;TLS介于哪两层之间？对应用层透明吗？"></a>SSL&#x2F;TLS介于哪两层之间？对应用层透明吗？</h3><p>介于传输层和应用层之间。<br>对应用层透明。</p><h3 id="TCP协议头部长度使用哪个字段？如何计算？"><a href="#TCP协议头部长度使用哪个字段？如何计算？" class="headerlink" title="TCP协议头部长度使用哪个字段？如何计算？"></a>TCP协议头部长度使用哪个字段？如何计算？</h3><p>使用<strong>头部长度</strong>字段，占4位，表示有多少个4字节，所以头部长度最多有15*4&#x3D;60个字节。同IP头部</p><h3 id="出现过多TIME-WAIT原因及解决方法"><a href="#出现过多TIME-WAIT原因及解决方法" class="headerlink" title="出现过多TIME_WAIT原因及解决方法"></a>出现过多TIME_WAIT原因及解决方法</h3><p>高并发短连接。<br>高并发：客户端连接比较多<br>短连接：业务处理+数据传输时间远小于TIME_WAIT时间的连接。<br>解决方法：开启tcp_tw_reuse和tcp_tw_recycle</p><h3 id="出现过多CLOSE-WAIT原因"><a href="#出现过多CLOSE-WAIT原因" class="headerlink" title="出现过多CLOSE_WAIT原因"></a>出现过多CLOSE_WAIT原因</h3><p>服务端处理完没有主动关闭连接。</p><h3 id="TCP连接在客户端宕机、拔掉网线、进程崩溃条件下分别发生什么？"><a href="#TCP连接在客户端宕机、拔掉网线、进程崩溃条件下分别发生什么？" class="headerlink" title="TCP连接在客户端宕机、拔掉网线、进程崩溃条件下分别发生什么？"></a>TCP连接在客户端宕机、拔掉网线、进程崩溃条件下分别发生什么？</h3><ul><li><strong>客户端宕机</strong>：<ul><li>没有数据传输：<ul><li>开启保活机制：达到最大重传次数后断开连接</li><li>没开启保活机制：服务端感知不到，一直处于连接建立状态。</li></ul></li><li>有数据传输：<ul><li>客户端重启：客户端收到服务端报文后回复RST报文</li><li>一直未重启：达到最大重传次数后断开连接</li></ul></li></ul></li><li><strong>拔掉网线</strong>：<ul><li>没有数据传输：<ul><li>开启保活机制：如果在探测期间插回了网线，则连接继续存在，否则断开连接。</li><li>没开启保活机制：连接一直存在</li></ul></li><li>有数据传输：<ul><li>在服务器重传次数达到最大之前插回网线：连接继续存在</li><li>没插回网线：服务器断开连接，客户端发送报文，得到回复的RST报文，断开连接。</li></ul></li></ul></li><li><strong>进程崩溃</strong>：向对方发送FIN报文。</li></ul><h3 id="TIME-WAIT状态接收到SYN报文怎么处理"><a href="#TIME-WAIT状态接收到SYN报文怎么处理" class="headerlink" title="TIME_WAIT状态接收到SYN报文怎么处理"></a>TIME_WAIT状态接收到SYN报文怎么处理</h3><p>如果打开<strong>tcp_tw_reuse</strong>参数，且<strong>SYN报文序列号比服务端期待收到的下一个报文序列号大</strong>，且<strong>时间戳比服务端最后收到的报文时间戳大</strong>，则跳过2MSL重用此连接。否则回复一个RST报文</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2022/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="MySQL中的自增主键是严格递增的吗"><a href="#MySQL中的自增主键是严格递增的吗" class="headerlink" title="MySQL中的自增主键是严格递增的吗"></a>MySQL中的自增主键是严格递增的吗</h3><p>不一定严格递增。<br>导致自增主键不连续有两种原因：</p><ul><li>唯一键冲突</li><li>事务回滚<br>MySQL将自增值保存在内存中，当插入一条记录时，如果没有指定自增字段的值，就将其自增字段设为自增值，然后将自增值加一。如果此时因为唯一键冲突或事务回滚，导致插入失败，此时自增值不会回滚，再插入数据时，自增主键就会出现不连续。</li></ul><h3 id="针对上述问题，为什么自增主键不能回退"><a href="#针对上述问题，为什么自增主键不能回退" class="headerlink" title="针对上述问题，为什么自增主键不能回退"></a>针对上述问题，为什么自增主键不能回退</h3><p>假设事务A和事务B并行执行，在申请自增值的时候加锁，顺序申请。假设事务A先申请到id&#x3D;1，当前自增值为2，事务B申请到id&#x3D;2，自增值为3，然后事务A、B都插入，假设B先插入成功，事务A插入时发生唯一键冲突或事务回滚，如果允许自增键回滚，则自增键回退为1，假如事务A继续插入，申请到id&#x3D;1，再插入id&#x3D;2，由于事务B已经插入id&#x3D;2的数据，此时就会发生主键冲突。<br>为了避免这种情况，就需要通过在每次申请之前判断表中是否存在对应id，或者扩大锁的范围，但都会影响性能，所以设置自增主键不能回退。</p><h3 id="关键字执行顺序"><a href="#关键字执行顺序" class="headerlink" title="关键字执行顺序"></a>关键字执行顺序</h3><ol><li>from</li><li>on</li><li>join</li><li>where</li><li>group by</li><li>having</li><li>select</li><li>distinct</li><li>order by</li><li>limit</li></ol><h3 id="存储引擎的区别及应用场景"><a href="#存储引擎的区别及应用场景" class="headerlink" title="存储引擎的区别及应用场景"></a>存储引擎的区别及应用场景</h3><h3 id="join-on和where的区别"><a href="#join-on和where的区别" class="headerlink" title="join on和where的区别"></a>join on和where的区别</h3><h3 id="什么是刷脏？刷脏时机？"><a href="#什么是刷脏？刷脏时机？" class="headerlink" title="什么是刷脏？刷脏时机？"></a>什么是刷脏？刷脏时机？</h3><p>刷脏：将脏页写入磁盘<br>刷脏时机：<br>    * redo log写满了<br>    * 内存不足，需要淘汰一些内存页，如果是脏页则刷脏<br>    * 数据库系统空闲<br>    * 数据库正常关闭</p><h3 id="mysql记录格式"><a href="#mysql记录格式" class="headerlink" title="mysql记录格式"></a>mysql记录格式</h3><ul><li>compact格式：<ul><li>变长字段长度列表：记录一行中所有变长字段的真实数据所占用的字节长度。只保存值为非NULL的列占用的字节。</li><li>NULL值列表：存放值为null的列，采用位图的方式，每个列对应一个二进制位，值为1代表该列值为Null。</li><li>记录头信息：标识记录的一些属性信息，如该行是否已经被删除、数据页中下一条记录的位置等。</li><li>隐藏列：<ul><li>事务ID</li><li>undo记录</li></ul></li><li>真实数据：不存放Null值的列</li></ul></li><li>Dynamic格式：和Compact基本一致。区别在于Compact格式中，对于溢出数据，存放其前768字节和指向溢出页的指针。Dynamic格式不存放数据，只保留一个指向溢出页的指针，实际数据都存放在溢出页中。</li></ul><p>行溢出：一个数据页大小为16KB，最多放16384字节，一个可变长记录最大65532字节，对于溢出部分，开辟新的<strong>溢出页</strong>存放，并在记录真实数据中存放指向溢出页的指针。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>管理计算机软件和硬件的程序，操作系统的<strong>内核作为应用和硬件设备的桥梁</strong>，应用只需关注与内核的交互，不用关心硬件的细节</p><h3 id="内核的作用"><a href="#内核的作用" class="headerlink" title="内核的作用"></a>内核的作用</h3><ul><li>进程调度</li><li>内存管理</li><li>硬件通信</li><li>系统调用</li></ul><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>当运行在用户态的程序需要使用系统级别的资源相关的操作，就需要通过系统调用向操作系统提出请求，由操作系统代为完成。<br>系统调用功能包括：</p><ul><li>设备管理</li><li>文件管理</li><li>进程管理</li><li>内存管理</li></ul><h3 id="如何实现用户态和内核态的切换"><a href="#如何实现用户态和内核态的切换" class="headerlink" title="如何实现用户态和内核态的切换"></a>如何实现用户态和内核态的切换</h3><ul><li>系统调用</li><li>异常：如缺页中断</li><li>中断：外部设备引发的中断，属于硬中断</li></ul><h3 id="用户态到内核态切换过程"><a href="#用户态到内核态切换过程" class="headerlink" title="用户态到内核态切换过程"></a>用户态到内核态切换过程</h3><p>主要涉及用户栈和内核栈的转换。</p><ol><li>保存当前寄存器（栈指针、程序计数器、通用寄存器）</li><li>将栈指针指向内核栈地址，将CPU状态设为内核态</li><li>执行内核方法</li><li>执行完毕后，将CPU字段改为用户态，并根据之前的上下文恢复用户栈的执行</li></ol><h3 id="如何避免用户态和内核态的频繁切换"><a href="#如何避免用户态和内核态的频繁切换" class="headerlink" title="如何避免用户态和内核态的频繁切换"></a>如何避免用户态和内核态的频繁切换</h3><ol><li>减少线程切换<ul><li>减少锁的使用：加锁和解锁会引起用户态和内核态的切换，Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行。</li><li>避免创建不必要的线程</li><li>使用协程</li></ul></li><li>针对I&#x2F;O导致的系统调用，设置用户进程缓冲区，读取数据时直接在用户态的缓冲区里读取。</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存地址和物理内存地址"><a href="#虚拟内存地址和物理内存地址" class="headerlink" title="虚拟内存地址和物理内存地址"></a>虚拟内存地址和物理内存地址</h3><p>虚拟内存：程序使用的内存<br>物理内存：实际存在硬件里的地址</p><h3 id="虚拟地址作用"><a href="#虚拟地址作用" class="headerlink" title="虚拟地址作用"></a>虚拟地址作用</h3><ul><li>可以使进程使用的内存超过物理内存大小</li><li>解决多进程之间地址冲突</li><li>页表项中有一些标记属性，可以控制一个页的读写权限、页是否存在等，为内存访问提供更好的安全性</li></ul><h3 id="虚拟地址如何管理"><a href="#虚拟地址如何管理" class="headerlink" title="虚拟地址如何管理"></a>虚拟地址如何管理</h3><p>分段、分页、段页式。</p><ul><li><strong>分段</strong>：进程按逻辑分为<strong>代码段、数据段、堆段、栈段</strong>。虚拟地址由<strong>段号、特权标志位和偏移量</strong>组成，段表里保存的是<strong>段的基地址和段界限</strong>，根据段号到段表中找到对应段的基地址，如果偏移量位于0和段界限之间则为合法地址，将段的基地址加上偏移量得到物理地址。<br> 分段缺点：<ul><li>内存碎片</li><li>内存交换效率低</li></ul></li><li><strong>分页</strong>：虚拟地址由<strong>页号和页内偏移量</strong>组成，页表由<strong>虚拟页号和对应的物理页号</strong>组成，根据虚拟地址页号找到物理页号，加上偏移量得到物理地址。</li><li><strong>段页式</strong>：先分段，每个段再分页。虚拟地址由<strong>段号、段内页号和页内偏移量</strong>组成。段表里存的是<strong>段号和对应的页表地址</strong>，页表里存的是<strong>虚拟页号和对应的物理页号</strong>。</li></ul><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>为了解决页表项过多，占用过多内存的问题。<br>将页表分为1024个页表项，每个页表项对应一个页表（二级页表），二级页表只有在使用到对应的一级页表的页表项时才创建。</p><h3 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h3><p>多级页表的转换次数变多，降低了地址转换的速度。<br>TLB放在CPU中，相当于一个缓存，里面保存常用的页表项。CPU寻址时先查TLB，如果查不到再查页表。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><p>系统对发生的某个事件做出的一种反应，暂停正在执行的程序，保留现场后调用中断处理程序处理事件，处理完该事件后再返回断点继续执行被打断的程序。</p><h3 id="软中断和硬中断"><a href="#软中断和硬中断" class="headerlink" title="软中断和硬中断"></a>软中断和硬中断</h3><p><strong>硬中断</strong>：硬件触发的中断，会打断正在执行的进程<br><strong>软中断</strong>：内核触发的中断<br>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：</p><ul><li>上半部，对应<strong>硬中断</strong>，由硬件触发中断，用来快速处理中断；</li><li>下半部，对应<strong>软中断</strong>，由内核触发中断，用来异步处理上半部未完成的工作；</li></ul><h3 id="请求分页工作流程"><a href="#请求分页工作流程" class="headerlink" title="请求分页工作流程"></a>请求分页工作流程</h3><h3 id="用户态转换到内核态的过程"><a href="#用户态转换到内核态的过程" class="headerlink" title="用户态转换到内核态的过程"></a>用户态转换到内核态的过程</h3><p>用户态到内核态的切换发生在以下情况：</p><ul><li>异常</li><li>系统调用</li><li>外部中断<br>用户态到内核态切换过程中发生cpu上下文切换，整个过程为：<br>保存CPU寄存器中用户栈的执行位置<br>CPU寄存器更新为内核栈的指令位置<br>进入内核态执行内核任务<br>系统调用结束后，CPU恢复保存的用户栈，切换为用户空间继续执行</li></ul><h3 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a>进程切换过程</h3><p>进程上下文包括<strong>虚拟内存、栈、全局变量、内核栈、寄存器</strong>。<br>切换时将这些信息保存在PCB中。</p><h3 id="什么时候发生进程上下文切换"><a href="#什么时候发生进程上下文切换" class="headerlink" title="什么时候发生进程上下文切换"></a>什么时候发生进程上下文切换</h3><ul><li>进程调度</li><li>内存不足时，要等待资源满足才能继续运行，此时会被挂起</li><li>通过sleep主动挂起</li><li>硬件中断</li></ul><h3 id="线程切换过程"><a href="#线程切换过程" class="headerlink" title="线程切换过程"></a>线程切换过程</h3><h3 id="操作系统如何判断内存越界"><a href="#操作系统如何判断内存越界" class="headerlink" title="操作系统如何判断内存越界"></a>操作系统如何判断内存越界</h3><p>在每次申请内存时检测工具会多申请一些内存（前后32 byte，可以设置）放在真实内存前后，并赋值，当释放该内存时，会检查真实内存前后数值是否被篡改，如果被改则认为是内存越界。</p><h3 id="互斥锁的实现原理"><a href="#互斥锁的实现原理" class="headerlink" title="互斥锁的实现原理"></a>互斥锁的实现原理</h3><p>mutex的本质就是一个内存标志，这个标志可以是一个flag（占用标志），也可以是一个指针，指向一个持有者的线程ID，也可以是两个都有，以及一个等待（阻塞）队列，以及若干其它信息等。。当这个flag被标记成被占用的时候，或者持有者指针不为空的时候，那么它就不能被被别的任务（线程）访问。只有等到这个mutex变得空闲的时候，操作系统会把等待队列里的第一任务（线程）取出来，然后调度执行，如果当前CPU很忙，那么就把取出的这个任务（线程）标记为就绪（READY）状态，后续如果CPU空闲了，就会被调度。</p><p>这个占用标志flag，利用硬件的原子操作来实现，比如x86汇编里有CMPXCHG指令，就可以实现比较+原子交换，锁都是用这个实现的。单核CPU就是用这个实现的。操作mutex之前，还会关中断，保证这个操作的唯一性。</p><h3 id="kill原理"><a href="#kill原理" class="headerlink" title="kill原理"></a>kill原理</h3><h3 id="fork原理"><a href="#fork原理" class="headerlink" title="fork原理"></a>fork原理</h3>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O</title>
    <link href="/2022/08/20/IO/"/>
    <url>/2022/08/20/IO/</url>
    
    <content type="html"><![CDATA[<h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h3><p>字节流：每次读&#x2F;写一个字节，当传输的资源文件有中文时，就会出现乱码，读写的单位是byte<br>字符流：每次读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)<br>字节流可以处理一切文件，而字符流只能处理纯文本文件。<br>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</p><h3 id="为什么要有字符流"><a href="#为什么要有字符流" class="headerlink" title="为什么要有字符流"></a>为什么要有字符流</h3><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还比较耗时，同时编码转换过程也很容易出现乱码问题。所以单独提出字符流。</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步异步关注的是消息通信机制。<br>同步：在发出一个调用后，没有得到结果之前该调用不返回。<br>异步：调用发出之后直接返回，被调用者处理完之后通知调用者。</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞关注的是等待调用结果时线程的状态。<br>阻塞：在得到结果之前该线程被挂起。<br>非阻塞：等待结果过程中线程可以做别的事。</p><h3 id="5种I-x2F-O模型"><a href="#5种I-x2F-O模型" class="headerlink" title="5种I&#x2F;O模型"></a>5种I&#x2F;O模型</h3><ul><li><strong>同步阻塞I&#x2F;O</strong>：应用程序发起read()系统调用后，一直阻塞，直到内核把数据拷贝到用户空间。</li><li><strong>同步非阻塞I&#x2F;O</strong>：在等待数据准备过程中，进程不阻塞，而是不断轮询查看数据是否准备好，在数据从内核缓冲区拷贝到用户空间过程中仍然阻塞。</li><li><strong>I&#x2F;O多路复用</strong>：可以使用一个进程处理多个IO事件。通过select&#x2F;poll&#x2F;epoll监控多个socket，等待其有事件发生，这一过程会阻塞，当某个socket可读时返回，再将数据从内核空间拷贝到用户空间。</li><li><strong>信号驱动I&#x2F;O</strong>：等待数据准备过程不阻塞，数据准备完成后通过信号通知应用程序，将数据从内核缓冲区拷贝到用户缓冲区，这个过程阻塞。</li><li><strong>异步I&#x2F;O</strong>：应用程序始终不阻塞，数据准备好，内核直接拷贝到用户空间，拷贝完通知应用程序。</li></ul><h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><h3 id="多路复用解决什么问题"><a href="#多路复用解决什么问题" class="headerlink" title="多路复用解决什么问题"></a>多路复用解决什么问题</h3><p>当有多个客户端连接时，如果使用传统I&#x2F;O模型，需要为每个链接创建一个进程或线程，当客户端数量较多时，进程&#x2F;线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。<br>为了解决上面这个问题，就出现了 I&#x2F;O 的多路复用，可以只在一个进程里处理多个文件的 I&#x2F;O</p><h3 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h3><ul><li><p>select将所有已连接的socket放到一个文件描述符集合里，然后调用select函数将其<strong>拷贝到内核空间中</strong>，由内核检测事件发生，当有网络事件产生时，内核需要<strong>遍历</strong> Socket 集合，找到对应的 Socket，并设置其状态为可读&#x2F;可写，然后把整个 Socket 集合<strong>从内核态拷贝到用户态</strong>，用户态还要继续<strong>遍历</strong>整个 Socket 集合找到可读&#x2F;可写的 Socket，然后对其处理。<br>poll的原理和select基本一样，区别在于select用bitmap保存socket，poll采用链表。<br>select&#x2F;poll的缺点在于当客户端较多，遍历和拷贝会带来很大开销。</p></li><li><p>epoll可以解决C10K问题：</p><ul><li>epoll 在内核里使用<strong>红黑树</strong>来关注进程所有待检测的 Socket，通过对这棵黑红树的管理，不需要像 select&#x2F;poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>epoll 使用事件驱动的机制，内核里维护了一个<strong>链表</strong>来<strong>记录就绪事件</strong>，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select&#x2F;poll 那样轮询扫描整个集合，大大提高了检测的效率。</li></ul></li></ul><h3 id="边缘触发-ET-和水平触发-LT"><a href="#边缘触发-ET-和水平触发-LT" class="headerlink" title="边缘触发(ET)和水平触发(LT)"></a>边缘触发(ET)和水平触发(LT)</h3><ul><li><strong>边缘触发</strong>：当被监控的socket上有可读写事件发生时，内核只会通知用户一次，在收到通知后应尽可能地读写数据。</li><li><strong>水平触发</strong>：当被监控的 Socket 上有可读写事件发生时，内核会不断通知用户，直到内核缓冲区数据被 read 函数读完才结束</li><li>边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是同步非阻塞IO模型，核心包括Channel、Buffer、Selector三个部分。</p><ul><li><strong>缓冲区Buffer</strong>:NIO是面向缓冲区的，其本质是一个数组，Buffer中存放要读写的数据，任何时候访问数据都要通过Buffer。相比于面向流的优点：面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。面向缓冲区可以将数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，增加了处理过程中的灵活性。</li><li><strong>Channel</strong>:用来传输数据，与流相比，Channel是双向的（NIO面向缓冲区，双向传输），既可以读又可以写，而流是单向的。</li><li><strong>Selector</strong>:底层使用epoll(),Selector会不断地轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channnel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I&#x2F;O操作。</li></ul><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。<br>零拷贝即<strong>没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据</strong>，所有的数据都是通过 DMA 来进行传输的。<br>用mmap()代替read()：mmap()会直接把内核缓冲区种的数据<strong>映射</strong>到用户空间，<strong>减少一次cpu拷贝</strong><br>用sendfile()代替read()和write()：可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就<strong>只有 2 次上下文切换，和 3 次数据拷贝。</strong> 如果网卡支持SG-DMA技术，可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就<strong>减少了一次数据拷贝</strong>，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p><h3 id="PageCache作用"><a href="#PageCache作用" class="headerlink" title="PageCache作用"></a>PageCache作用</h3><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p>当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「<strong>热点</strong>」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用 <strong>异步 IO + 直接 IO</strong> 的方式。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/08/19/JVM/"/>
    <url>/2022/08/19/JVM/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要虚拟机"><a href="#为什么需要虚拟机" class="headerlink" title="为什么需要虚拟机"></a>为什么需要虚拟机</h3><ul><li>提供跨平台特性：虚拟机将源代码编译后得到的字节码文件翻译成特定平台下的机器码，然后运行，只要在不同平台安装相应的JVM，就可以实现一次编译到处运行</li><li>提供内存管理和垃圾回收的能力</li><li>提供诸如数组越界、安全权限等动态检测能力</li></ul><h3 id="java代码执行过程"><a href="#java代码执行过程" class="headerlink" title="java代码执行过程"></a>java代码执行过程</h3><p><strong>编译-&gt;加载-&gt;解释-&gt;执行</strong></p><ul><li>编译：将源文件翻译成字节码文件</li><li>加载：类加载</li><li>解释：当执行一个类的方法时，到方法区中找到对应方法的字节码信息，然后解释器将字节码解释成机器码</li><li>执行</li></ul><h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p><strong>线程共享：</strong></p><ul><li>堆：<strong>几乎所有对象</strong>都在堆里分配内存<ul><li>堆中可能出现OOM异常</li></ul></li><li>方法区：存储类信息，如：<strong>类信息、字段信息、方法信息、常量、编译好的代码缓存</strong>等。1.7之前还存储<strong>字符串常量池、静态变量</strong>，1.7之后都放在堆里。<ul><li>方法区中可能出现OOM</li></ul></li></ul><p><strong>线程私有：</strong></p><ul><li>程序计数器：记录线程指令执行位置，用于控制代码执行以及上下文切换时保存执行位置。</li><li>虚拟机栈：负责方法的调用。栈帧由<strong>局部变量表、操作数栈、动态链接、方法返回地址</strong>构成。<br>栈中可能出现错误：<ul><li>StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li>OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul></li><li>本地方法栈：负责native方法的调用，即非java实现方法的接口。</li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>加载：<ul><li>通过全类名获取对应的.class文件，并加载到内存</li><li>将class文件中的静态存储结构转换成方法区中的数据结构</li><li>在堆中生成对应的Class对象</li></ul></li><li>验证：确保加载的类符合JVM规范</li><li>准备：为static变量分配内存，并赋零值</li><li>解析：将符号引用转换为直接引用</li><li>初始化：给static变量显式赋值，并执行静态代码块<ul><li>初始化发生在以下情况：</li><li>创建一个类的对象、访问静态变量、给类的静态变量赋值、调用类的静态方法</li><li>使用反射进行调用</li><li>初始化一个类时，如果其父类没初始化，先初始化其父类</li><li>先初始化包含main方法的类</li></ul></li><li>卸载：<ul><li>该类的所有对象都被回收</li><li>该类对应的Class对象没有在任何地方被引用</li><li>加载该类的类加载器被回收</li></ul></li></ul><h3 id="类加载的顺序"><a href="#类加载的顺序" class="headerlink" title="类加载的顺序"></a>类加载的顺序</h3><ol><li>父类静态字段或静态代码块</li><li>子类静态字段或静态代码块</li><li>父类普通变量及代码块</li><li>父类构造函数</li><li>子类普通变量及代码块</li><li>子类构造方法</li></ol><p>（注：加载一个类时，其内部类不会同时被加载，只有其静态成员或构造方法被调用时加载）</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。<br>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><h3 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h3><p>重写classloader的loadclass()方法</p><h3 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h3><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><ul><li><p>类加载检查：先检查对应类是否已加载，如果没有则先进行类加载</p></li><li><p>分配内存：为对象分配内存。根据垃圾回收算法选择不同分配策略：</p><ul><li>指针碰撞：适用堆内存规整的情况，用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>空闲列表：使用堆内存不规整情况，分配的时候，找一块儿足够大的内存块儿来划分给对象实例</li></ul><p>分配内存时为了保证线程安全，使用两个策略：</p><ul><li>CAS+重试</li><li>TLAB：在Eden区为每个线程分配一块区域，分配内存时优先在这块区域分配，内存不够再CAS进行内存分配</li></ul></li><li><p>初始化零值</p></li><li><p>设置对象头</p></li><li><p>按构造方法进行初始化</p></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul><li>对象头：<ul><li>存储自身运行时数据（哈希码、分代年龄、锁标志位等）</li><li>类型指针：指向类元数据</li><li>数组对象还存储数组长度</li></ul></li><li>实例数据：存放各字段内容</li><li>对齐填充</li></ul><h3 id="对象头占几个字节"><a href="#对象头占几个字节" class="headerlink" title="对象头占几个字节"></a>对象头占几个字节</h3><ul><li>Markword占<strong>8字节</strong>（64位），32位操作系统占4字节</li><li>指针占<strong>8字节</strong>，如果开启<strong>指针压缩</strong>占4字节</li><li>数组长度：<strong>4字节</strong></li></ul><p>对齐填充按8字节的倍数填充，因为64位操作系统内存访问时一次寻址的指针大小是8字节，如果不进行内存对齐，则可能出现跨缓存行的情况，这叫做 <strong>缓存行污染</strong>。例如：如果对象A的和对象B在一个缓存行里，当修改了对象A的字段后，再访问B时，就需要重新将A加载到缓存行中，影响执行效率。</p><h3 id="指针压缩原理"><a href="#指针压缩原理" class="headerlink" title="指针压缩原理"></a>指针压缩原理</h3><p>32位系统可以访问2^32&#x3D;4GB(每一位代表一个字节)地址空间，64位系统理论上可以访问无限空间，但每个引用占8字节，会占据过多堆内存，所以进行指针压缩。<br>由于每个对象大小是8字节的整数倍，所以可以没8个字节作为一个索引。例如对象A、B、C的内存地址分别为0、8、16,就可以映射为0、1、2, 由于是8字节的倍数，所以最后三位一定是0，所以存储时可以将后3位0抹去（转换为bit就是抹去后24位），再将最高位抹去，8字节指针就压缩成了4字节。使用时只要在压缩后的指针后面加3个0，就可以映射回真实地址。<br>完成压缩后，指针的32bit中每个bit都代表8字节，所以最大可以表示 在32位的基础上 2^32*8&#x3D;32GB内存。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul><li>句柄：堆中划分出一块区域存放句柄池，引用中存的是句柄地址，句柄池中存放指向对象实例数据的指针和指向对象类型数据的指针</li><li>直接指针：引用直接指向对象，java对象中存放实例数据和指向类型数据的指针</li></ul><p>句柄好处是如果对象移动只会改变句柄指针，而不用改变引用地址；直接指针好处是访问更快，减少一次指针定位。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="堆的内存区域"><a href="#堆的内存区域" class="headerlink" title="堆的内存区域"></a>堆的内存区域</h3><p>新生代、老年代、永久代（属于方法区，1.8以后被元空间取代）<br><strong>新生代和老年代比例为2：1</strong></p><h3 id="内存分配原则"><a href="#内存分配原则" class="headerlink" title="内存分配原则"></a>内存分配原则</h3><ul><li><strong>对象优先在Eden区分配</strong>，Eden区内存不够将发起一次Minor GC，仍存活的对象进入survivor区的To区，survivor的From区经历GC后，年代达到老年代的晋升到老年代，剩余对象移到To区，然后From区和To区互换。</li><li><strong>大对象直接进入老年代</strong>，如字符串、数组等需要大量连续空间的对象</li><li><strong>长期存活的对象进入老年代</strong></li><li><strong>动态年龄判定</strong>：如果survivor区中某个年龄的对象大小超过总大小的一半，则晋升至老年代，并将该年龄和当前晋升年龄阈值中的最小值设为新的阈值。</li><li><strong>空间分配担保</strong>：发生Minor GC之前，先检查老年代最大连续可用空间是否大于新生代所有对象空间，如果成立，则进行Minor GC。如果不成立，检查是否允许空间担保失败，如果允许，检查老年代空间是否大于历次晋升对象的平均大小，如果大于进行Minor GC，否则进行Full GC。</li></ul><h3 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h3><p>提升内存回收效率。如果都放在一起，每次垃圾回收都要扫描整个堆。</p><h3 id="为什么需要两个survivor区"><a href="#为什么需要两个survivor区" class="headerlink" title="为什么需要两个survivor区"></a>为什么需要两个survivor区</h3><p>如果没有survivor区，每次eden区回收后存活的对象都直接进入老年代，老年代内存很快会被用完。<br>设置两个survivor区是因为可以使用标记复制算法，因为新生代对象回收频繁，如果使用标记清除会产生较多内存碎片，使用标记整理的效率又不高，所以分成两个survivor使用标记复制算法。</p><h3 id="Full-GC触发条件"><a href="#Full-GC触发条件" class="headerlink" title="Full GC触发条件"></a>Full GC触发条件</h3><p>调用System.gc() 建议虚拟机执行Full GC<br>老年代空间不足<br>空间分配担保失败<br>1.7之前永久代空间不足<br>CMS产生Concurrent Node Failure</p><h3 id="如何判断对象已经死亡"><a href="#如何判断对象已经死亡" class="headerlink" title="如何判断对象已经死亡"></a>如何判断对象已经死亡</h3><ul><li>引用计数法：存在对象<strong>互相引用</strong>问题</li><li>可达性分析：选择一系列GC ROOTS，如果没有与任何GC ROOT节点的引用链相连，则认为死亡。<br>GC ROOTS选择标准：<ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中常量引用的对象</li><li>方法区中静态变量引用的对象</li></ul></li></ul><h3 id="对象可以被回收就一定会回收吗"><a href="#对象可以被回收就一定会回收吗" class="headerlink" title="对象可以被回收就一定会回收吗"></a>对象可以被回收就一定会回收吗</h3><p>不一定。对象回收要经历两次标记，第一次标记中，检查对象是否实现了finalize()方法且未执行过，先执行finalize()方法，之后进行第二次标记，如果此时仍未与GC ROOTs相连，则进行回收。</p><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>将所有对象分为黑白灰三色，黑色代表与之相连节点都已标记，灰色代表相连节点未标记。将所有GC ROOTs标记为灰色并入栈，依次出栈并将与其相连的对象设为灰色并入栈，将其设为黑色，重复上述过程，最后只剩黑白两色对象，白色对象为被回收对象。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li><strong>强引用</strong>：如果一个对象具有强引用，不会被回收</li><li><strong>软引用</strong>：如果一个对象只有软引用，只在内存不足时进行回收</li><li><strong>弱引用</strong>：如果一个对象只有弱引用，无论内存是否充足都回收</li><li><strong>虚引用</strong>：与引用队列联合使用，在回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记清除：存在效率问题和空间碎片</li><li>标记复制</li><li>标记整理</li><li>分代收集：新生代由于每次都有大量对象死去，所以一般选择效率较高的标记复制算法，老年代对无法分出额外空间，所以选择标记清除或标记整理算法。</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul><li><p>Serial:</p><ul><li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li><li>回收时只有一个GC线程，且STW</li></ul></li><li><p>ParNew:</p><ul><li>新生代采用标记-复制算法，老年代采用标记-整理算法。</li><li>Serial的多线程版本</li></ul></li><li><p>Parallel Scavenge：</p><ul><li>新生代采用标记-复制算法，老年代采用标记-整理算法。</li><li>更关注吞吐量，提供很多参数用来获得最大吞吐量或最合适的停顿时间</li></ul></li><li><p>Serial Old:</p><ul><li>Serial的老年代版本，作为CMS的后备回收器</li></ul></li><li><p>Parallel Old:</p><ul><li>ParNew的老年代版本</li></ul></li><li><p>CMS:</p><ul><li>使用标记清除</li><li>回收过程：<ul><li>初始标记：STW，标记与GC ROOT直接相连的对象。</li><li>并发标记</li><li>重新标记：STW，标记并发标记阶段由不可达变为可达的对象</li><li>并发清除</li></ul></li><li>缺点：<ul><li>内存碎片</li><li>无法处理浮动垃圾：并发标记时之前可达的对象变为不可达，重新标记时无法修改</li></ul></li></ul></li><li><p>G1：</p><ul><li>将堆分为一个个region，整体上看基于标记整理，局部上看基于标记复制，支持可预测的停顿，G1 收集器根据每个region回收时间和回收后获得的空间在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region</li><li>回收过程：<ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul></li></ul></li></ul><h3 id="JDK8默认使用的垃圾收集器是什么"><a href="#JDK8默认使用的垃圾收集器是什么" class="headerlink" title="JDK8默认使用的垃圾收集器是什么"></a>JDK8默认使用的垃圾收集器是什么</h3><p>Parallel Scavenge + Parallel Old</p><h3 id="为什么用Serial-Old作为CMS的后备回收器"><a href="#为什么用Serial-Old作为CMS的后备回收器" class="headerlink" title="为什么用Serial Old作为CMS的后备回收器"></a>为什么用Serial Old作为CMS的后备回收器</h3><p>当CMS出现Concurrent Mode Failure错误时，启用Serial Old代替CMS，出现这个错误是由于并发标记过程中产生的新对象大小超过了CMS预留的内存大小，所以采用单线程的Serial Old代替。<br>同时由于cms使用标记清除算法，随着使用次数的增多，内存中会有很多碎片空间无法利用，当达到一定阈值时，会使用serial old，serial old使用标记整理算法，能整合之前产生的碎片空间。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul><li>降低资源消耗：复用已有线程</li><li>提高响应速度：不需要等任务到达再创建线程</li><li>提高线程的可管理性：统一对线程进行分配、监控和管理</li></ul><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>由三部分组成：</p><ul><li>任务（Runnable&#x2F;Callable)</li><li>执行器（Executor）</li><li>异步计算的结果（Future）</li></ul><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><h3 id="7个线程池参数"><a href="#7个线程池参数" class="headerlink" title="7个线程池参数"></a>7个线程池参数</h3><ul><li>核心线程数</li><li>工作队列</li><li>最大线程数</li><li>线程存活时间</li><li>存活时间单位</li><li>线程工厂</li><li>拒绝策略</li></ul><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><ul><li>直接拒绝任务</li><li>直接拒绝任务并抛出异常</li><li>由当前执行任务的线程执行</li><li>丢弃最早的未处理请求</li></ul><h3 id="线程池原理-x2F-执行流程"><a href="#线程池原理-x2F-执行流程" class="headerlink" title="线程池原理&#x2F;执行流程"></a>线程池原理&#x2F;执行流程</h3><img src="/2022/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.png" class="" title="线程池原理"><h3 id="keepalive原理"><a href="#keepalive原理" class="headerlink" title="keepalive原理"></a>keepalive原理</h3><p>线程获取任务时，先判断是否设置了timed，如果设置了则通过阻塞队列的poll()方法获取任务，否则通过take()方法，poll()方法可以设置超时时间，当超过keepalive时间还没获得到任务的话，会设置timeout属性为true并返回null，在runWorker()方法中，判断到getTask()方法返回Null，则结束线程。</p><h3 id="Runnable和Callable区别"><a href="#Runnable和Callable区别" class="headerlink" title="Runnable和Callable区别"></a>Runnable和Callable区别</h3><p>Runnable提交的任务不返回结果，Callable可以返回结果。</p><h3 id="execute-和-submit-区别"><a href="#execute-和-submit-区别" class="headerlink" title="execute() 和 submit() 区别"></a>execute() 和 submit() 区别</h3><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成</li></ul><h3 id="shutdown-和shutdownNow-区别"><a href="#shutdown-和shutdownNow-区别" class="headerlink" title="shutdown()和shutdownNow()区别"></a>shutdown()和shutdownNow()区别</h3><ul><li>shutdown（） :关闭线程池，线程池的状态变为 <strong>SHUTDOWN</strong>。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕。</strong></li><li>shutdownNow（） :关闭线程池，线程的状态变为 <strong>STOP</strong>。线程池会<strong>终止当前正在运行的任务，并停止处理排队的任务</strong>并返回正在等待执行的 List。</li></ul><h3 id="isShutdown-和isTerminated-区别"><a href="#isShutdown-和isTerminated-区别" class="headerlink" title="isShutdown()和isTerminated()区别"></a>isShutdown()和isTerminated()区别</h3><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><p>通过Executors类中方法创建的几个线程池（本质都是通过调用ThreadPoolExecutor的构造方法创建）：</p><ul><li>FixedThreadPool：使用<strong>无界队列</strong>，线程数固定，任务过多会导致内存溢出。</li><li>SingleThreadExecutor：使用<strong>无界队列</strong>，只有一个线程，任务过多会导致内存溢出 </li><li>CachedThreadPool：核心线程数设为0，<strong>最大线程数无限</strong>，可能会创建大量线程导致OOM</li></ul><p>ScheduledThreadPoolExecutor：主要用来在给定的延迟后运行任务，或者定期执行任务</p><p>Fork&#x2F;Join:<strong>分治算法</strong>和<strong>工作窃取</strong></p><h3 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="线程池大小确定"></a>线程池大小确定</h3><ul><li><strong>CPU 密集型任务：</strong> 线程数设置为N+1，这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务：</strong> 线程数设置为2N，这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/19/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2022/08/19/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 并发集合类<br>date: 2022-08-11 19:07:07<br>tags:</p><ul><li>面经<br>categories:</li><li>面经</li><li>并发</li></ul><hr><h2 id="并发集合框架"><a href="#并发集合框架" class="headerlink" title="并发集合框架"></a>并发集合框架</h2><img src="/2022/08/19/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E7%B1%BB/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" class="" title="加锁解锁"><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>1.7：在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，它通过继承 ReentrantLock来进行加锁，每次锁住的是一个 segment，<strong>segment数量默认是16</strong>。<br>1.8：<strong>数组+链表+红黑树。</strong> 加锁采用<strong>CAS+Synchronized</strong>实现</p><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>1.7：<br>put()操作：1.7使用头插法。如果put()和get()并发执行，get()发生在put()之前，不影响。如果get()发生在put()之后，通过**UNSAFE.putOrderedObject()**（相当于volatile写)保证头节点可见。<br>扩容：扩容先创建数组，然后迁移数据，最后将table设为newtable。如果get先行，就是在旧数组上操作，如果先扩容，table是由volatile修饰的，可以保证可见性。<br>remove()操作：如果get()已经过去了则没问题。如果remove()先行，判断操作的是不是头节点，如果是头节点，通过UNSAFE类操作保证可见性，如果不是头节点，要将被删除节点的后继节点接到前驱节点后面，next属性是volatile的，可以保证可见性。</p><p>1.8：<br>put()操作：Node的val和next都是volatile的，所以get()可以获取最新值。<br>扩容：扩容通过两个链表保存节点，这两个链表中的节点是复制出来的，不影响原来链表，所以不影响get()操作。如果正在迁移的桶遇到put()&#x2F;remove()操作，则判断当前迁移是否完成，如果已经迁移完成，会将当前节点设为fwd节点，写线程会帮助扩容，如果未迁移完成，则头节点会被锁住，写线程阻塞。</p><h3 id="ConcurrentHashMap什么时候用到CAS"><a href="#ConcurrentHashMap什么时候用到CAS" class="headerlink" title="ConcurrentHashMap什么时候用到CAS"></a>ConcurrentHashMap什么时候用到CAS</h3><p>put()时如果<strong>插入位置头节点为空</strong>，则用<strong>CAS+自旋</strong>赋值。</p><h3 id="size-方法线程安全吗"><a href="#size-方法线程安全吗" class="headerlink" title="size()方法线程安全吗"></a>size()方法线程安全吗</h3><p>size()方法通过basecount(volatile修饰)和countcell类(包含一个volatile变量)计数。先用CAS对basecount加1，如果因并发失败，则创建一个countcell对象，计算size时将basecount和countcell对象数量加在一起得到总大小。<br>size()不加锁，当put()和size()同时发生可能出现统计不完全，故不是线程安全的。这样设计是为了不影响写入效率。</p><h3 id="1-7和1-8除了数据结构还有什么区别"><a href="#1-7和1-8除了数据结构还有什么区别" class="headerlink" title="1.7和1.8除了数据结构还有什么区别"></a>1.7和1.8除了数据结构还有什么区别</h3><ul><li>1.7使用ReentrantLock，1.8使用CAS+Synchronized</li><li>1.7只针对每个Segment内部多线程扩容，1.8支持整个表</li><li>技术统计：1.7put()时每个segment内部计数，统计时遍历每个segment加锁统计，1.8增加countcell类帮助计数</li></ul><h3 id="HashTable为什么慢"><a href="#HashTable为什么慢" class="headerlink" title="HashTable为什么慢"></a>HashTable为什么慢</h3><p>HashTable操作时通过Synchronized锁住整个表。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>读操作不加锁，写操作时加锁，并将数组复制一份，在新数组上进行写操作，然后将旧数组替换成新数组。table用volatile修饰。</p><h3 id="和vector的比较"><a href="#和vector的比较" class="headerlink" title="和vector的比较"></a>和vector的比较</h3><p>vector对每个操作都加锁，而COW读操作不加锁，只有写操作加锁</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>非阻塞链表，带有head和tail的单向链表，使用CAS添加和删除。</p><h3 id="HOPS-延迟更新的策略-的设计"><a href="#HOPS-延迟更新的策略-的设计" class="headerlink" title="HOPS(延迟更新的策略)的设计"></a>HOPS(延迟更新的策略)的设计</h3><ul><li>tail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。 </li><li>head更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</li></ul><p>即head和tail都是隔一个更新一次，目的是减少CAS次数。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>ArrayBlockingQueue:数组<br>LinkedBlockingQueue：单向链表<br>PriorityBlockingQueue：堆，支持排序</p><table><thead><tr><th></th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(timeout, timeunit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2022/08/13/Linux/"/>
    <url>/2022/08/13/Linux/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h3><p>在 Linux 的文件系统中，保存在磁盘分区中的文件都分配一个编号，称为索引节点号(Inode Index)。<br><strong>硬链接：</strong> A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。<br>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，<strong>文件真正删除的条件是与之相关的所有硬连接文件均被删除。</strong><br><strong>软链接：</strong> 软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 <strong>A 的数据块中存放的只是 B 的路径名</strong>（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。<br>使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。</p><h3 id="如何查看某个端口号被哪个进程占用"><a href="#如何查看某个端口号被哪个进程占用" class="headerlink" title="如何查看某个端口号被哪个进程占用"></a>如何查看某个端口号被哪个进程占用</h3><ul><li>lsof -i:端口号  </li><li>netstat -anp | grep pid<br>查看所有端口：netstat -ntlp</li></ul><h3 id="如何查看文件和目录大小"><a href="#如何查看文件和目录大小" class="headerlink" title="如何查看文件和目录大小"></a>如何查看文件和目录大小</h3><p>du -sh</p><h3 id="统计文件中某个单词的出现次数"><a href="#统计文件中某个单词的出现次数" class="headerlink" title="统计文件中某个单词的出现次数"></a>统计文件中某个单词的出现次数</h3><p>cat 文件名 | grep -o 单词 | wc -l</p><h3 id="根据文件里数字排序"><a href="#根据文件里数字排序" class="headerlink" title="根据文件里数字排序"></a>根据文件里数字排序</h3><p>sort -n(按数字排序) -k(指定列数)</p><h3 id="top如何获取信息的"><a href="#top如何获取信息的" class="headerlink" title="top如何获取信息的"></a>top如何获取信息的</h3><p>通过查询&#x2F;proc目录下相关文件获取信息</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>ls: 列出当前目录下文件<br>cd: 切换目录<br>cp: 复制文件到指定目录<br>find: 查找文件<br>mkdir: 创建文件夹<br>mv: 移动文件到指定目录<br>rm: 删除文件或目录<br>cat: 查看文件<br>more: 分页查看文件<br>less: 分页查看文件，可以前后翻页、跳转、查找<br>tail: 显示文件最后几条记录<br>du: 查看磁盘空间使用情况<br>df: 查看文件系统磁盘使用情况<br>top: 实时监控当前系统正在执行的进程的相关信息<br>free: 查看系统内存情况<br>lsof: 用于查看你进程开打的文件，打开文件的进程，进程打开的端口<br>ps aux: 显示所有进程信息<br>ps -ef:显示所有进程信息<br>sed: 替换文件中的字符</p><h3 id="cpu内存占用率很高如何排查"><a href="#cpu内存占用率很高如何排查" class="headerlink" title="cpu内存占用率很高如何排查"></a>cpu内存占用率很高如何排查</h3><ol><li>通过<strong>top</strong>命令查看各个进程使用cpu情况，找到cpu使用率最高的进程  </li><li>通过 <strong>top -Hp 进程id</strong>查看该进程下各个线程的cpu使用情况</li><li>使用<strong>jstack 线程id</strong>命令查看当前进程的堆栈状态</li><li>根据之前获得的cpu占用率较高的线程pid，将该pid转成16进制的值，在thread dump中每个线程都有一个nid，找到对应的nid即可；隔段时间再执行一次jstack命令获取thread dump，区分两份dump是否有差别，如果发现一直在执行某个方法，就可以检查对应的代码是否有问题。</li></ol><h3 id="内存占用过高如何排查"><a href="#内存占用过高如何排查" class="headerlink" title="内存占用过高如何排查"></a>内存占用过高如何排查</h3><ol><li>通过<strong>top</strong>命令定位到内存占用过高的进程id</li><li>使用<strong>jstat -gccause pid</strong>命令查看该进程的gc情况</li><li>如果发现gc非常频繁，通过<strong>jmap</strong>命令查询进程实体类内存占用情况，检查哪个类的创建了过多的实体对象及内存泄漏情况</li><li>如果没有上述问题，通过<strong>jmap -heap</strong>查看堆的各个分代的使用情况，如果发生频繁gc是因为堆的分代大小设置有问题，可以修改各个分代大小</li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2022/08/11/JUC/"/>
    <url>/2022/08/11/JUC/</url>
    
    <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="JUC框架包含哪些部分"><a href="#JUC框架包含哪些部分" class="headerlink" title="JUC框架包含哪些部分"></a>JUC框架包含哪些部分</h3><ol><li>Lock框架和工具类：AQS、LockSupport、ReentrantLock、ReadWriteLock、工具类（Semaphore、CountdownLatch、CylicBarrier)</li><li>并发集合: ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、BlockingQueue</li><li>原子类</li><li>线程池</li></ol><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="对Unsafe类的理解"><a href="#对Unsafe类的理解" class="headerlink" title="对Unsafe类的理解"></a>对Unsafe类的理解</h3><ul><li>Unsafe类，主要提供一些用于底层操作的方法，如内存访问、内存管理等，使Java拥有直接操作内存的功能，同时也增加了不安全。</li><li>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类。</li></ul><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>通过 <strong>Atomic::cmpxchg</strong> 来实现比较和替换操作。如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p><h3 id="原子类有哪些"><a href="#原子类有哪些" class="headerlink" title="原子类有哪些"></a>原子类有哪些</h3><ol><li>基本类型原子类：</li></ol><ul><li>AtomicInteger：整型原子类 </li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><ol start="2"><li>数组类型原子类：</li></ol><ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><ol start="3"><li>引用类型原子类：</li></ol><ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。标记是否被更改。</li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><ol start="4"><li>对象的属性修改类型原子类</li></ol><ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul><h3 id="原子类原理"><a href="#原子类原理" class="headerlink" title="原子类原理"></a>原子类原理</h3><p>CAS + volatile</p><h2 id="LockSupport类"><a href="#LockSupport类" class="headerlink" title="LockSupport类"></a>LockSupport类</h2><h3 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h3><ul><li><strong>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</strong></li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传；</li></ul><h3 id="Object-wait-和Condition-await-的区别"><a href="#Object-wait-和Condition-await-的区别" class="headerlink" title="Object.wait()和Condition.await()的区别"></a>Object.wait()和Condition.await()的区别</h3><p>Condition.await()底层是调用<strong>LockSupport.park()<strong>来实现阻塞当前线程的。它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”</strong>释放锁</strong>，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p><h3 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h3><ul><li>都不会释放当前线程占有的锁资源；</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来，LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li><li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出，LockSupport.park()方法不需要捕获中断异常；</li></ul><h3 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h3><ul><li>wait()释放锁，park()不释放锁；</li><li><strong>wait()需要在synchronized或lock()中执行</strong>，避免多线程并发下notify()在wait()前执行，<strong>park()不需要，unpark()在park()前运行也可以；</strong></li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出，LockSupport.park()不需要捕获中断异常；</li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>参考链接：<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS的核心思想是，如果请求的资源空闲，就将当前申请资源的线程设为工作线程，并将共享资源设为锁定状态。如果被请求的资源被锁定，就需要一套等待机制及线程唤醒锁分配机制。这个机制通过CLH队列实现。<br>CLH队列是一个双向链表。<br>AQS使用volatile修饰的变量state表示锁的状态，通过CAS对其进行修改。</p><h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><ul><li>独占<br> <strong>ReentrantLock</strong>:支持公平锁和非公平锁。</li><li>共享<br> <strong>Semaphore、CountDownLatch、 CyclicBarrier</strong></li></ul><p><strong>ReentrantReadWriteLock</strong>是两种锁的组合。</p><h3 id="AQS核心方法"><a href="#AQS核心方法" class="headerlink" title="AQS核心方法"></a>AQS核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空并且头节点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头节点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>acquire()和release()使用模板方法，由实现类实现以下具体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><h3 id="AQS底层为什么设计成双向链表"><a href="#AQS底层为什么设计成双向链表" class="headerlink" title="AQS底层为什么设计成双向链表"></a>AQS底层为什么设计成双向链表</h3><ul><li>队列中节点尝试获取锁的条件是前置节点是头节点</li><li>唤醒线程时要从后向前遍历</li><li>判断一个节点是否要被阻塞要看前置节点的状态是否为SIGNAL</li></ul><p>所以设置成双向链表会更方便获取到前置节点的状态</p><h3 id="AQS为什么时线程安全的"><a href="#AQS为什么时线程安全的" class="headerlink" title="AQS为什么时线程安全的"></a>AQS为什么时线程安全的</h3><p>基于volatile+CAS实现</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="ReentrantLock和Synchronized的区别"><a href="#ReentrantLock和Synchronized的区别" class="headerlink" title="ReentrantLock和Synchronized的区别"></a>ReentrantLock和Synchronized的区别</h3><ul><li>Synchronized是关键字，ReentrantLock是JUC包下的工具类；</li><li>Synchronized只支持非公平锁，ReentranLock支持公平锁和非公平锁；</li><li>Synchronized和ReentranLock都是可重入锁</li><li>ReentrantLock可以和Condition一起使用，实现选择性通知，更加灵活；</li><li>ReentrantLock提供了等待可中断机制，通过 lock.lockInterruptibly()可以使正在等待的线程放弃等待</li></ul><h3 id="ReentrantLock的内部实现"><a href="#ReentrantLock的内部实现" class="headerlink" title="ReentrantLock的内部实现"></a>ReentrantLock的内部实现</h3><p>ReentrantLock有三个内部类，<strong>Sync、FairSync、NonFairSync</strong>，Sync类继承了AQS抽象类，FairSync和NonFairSync继承了Sync类。<br>ReentrantLock可以选择公平锁和非公平锁（默认非公平锁）。<br>非公平锁和公平锁区别：</p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</li></ul><h3 id="ReentrantLock加锁解锁过程"><a href="#ReentrantLock加锁解锁过程" class="headerlink" title="ReentrantLock加锁解锁过程"></a>ReentrantLock加锁解锁过程</h3><p>加锁解锁流程如下：</p><img src="/2022/08/11/JUC/%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81.png" class="" title="加锁解锁"><p>加锁：</p><ul><li><p>通过ReentrantLock的加锁方法Lock进行加锁操作。</p></li><li><p>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</p></li><li><p>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</p></li><li><p>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</p></li></ul><p>解锁：</p><ul><li><p>通过ReentrantLock的解锁方法Unlock进行解锁。</p></li><li><p>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</p></li><li><p>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</p></li><li><p>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</p></li></ul><h3 id="加锁失败如何处理"><a href="#加锁失败如何处理" class="headerlink" title="加锁失败如何处理"></a>加锁失败如何处理</h3><p>执行AQS的 <strong>addwaiter()</strong> 方法，将当前的线程构建成一个节点，通过CAS将其设置成双向队列的尾节点（只是CAS将其前向指针指向当前尾节点）。<br>加入队列后，执行 <strong>acquireQueued()</strong> 方法，通过自旋等待获取锁，出队列条件是：<strong>前一个节点是头节点，且当前节点获取锁成功。</strong><br>为了防止因死循环导致CPU资源被浪费，如果获取锁失败或前一个节点不是头节点，则通过shouldParkAfterFailedAcquire()方法判断是否要将当前线程挂起（<strong>被阻塞条件：前驱节点的waitStatus为-1</strong>），判断流程如下：</p><img src="/2022/08/11/JUC/shouldparkafterfailedacquire.png" class=""><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>在release()方法中调用tryRelease()释放锁成功后，通过<strong>unparkSuccessor()</strong> 方法唤醒后继节点。如果当前节点的下个节点是null或者下个节点被cancelled，就<strong>从后向前</strong>找到第一个waitStatus&lt;0的节点并唤醒。<br>从后往前找是因为入队是非原子操作（入队时先将前向指针指向当前尾节点，然后CAS将新加入节点设置成尾节点，但此时pred.next&#x3D;node可能还没执行），此时如果从前往后遍历就是断的。同时产生CANCELLED节点也会断开next指针，可能无法遍历到所有节点，所以从后往前遍历。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><img src="/2022/08/11/JUC/%E8%AF%BB%E5%86%99%E9%94%81.png" class=""><h3 id="什么是锁的升降级"><a href="#什么是锁的升降级" class="headerlink" title="什么是锁的升降级"></a>什么是锁的升降级</h3><p>锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p><p>主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程(记作线程T)获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p><h3 id="为什么不支持锁升级"><a href="#为什么不支持锁升级" class="headerlink" title="为什么不支持锁升级"></a>为什么不支持锁升级</h3><p>获取写锁之前，其他线程不能持有读锁。假设有两个线程都持有读锁，并且都想进行锁升级获得写锁，则两个线程都要等待对方释放读锁，造成死锁。</p><h3 id="本地线程计数器ThreadLocalHoldCounter作用"><a href="#本地线程计数器ThreadLocalHoldCounter作用" class="headerlink" title="本地线程计数器ThreadLocalHoldCounter作用"></a>本地线程计数器ThreadLocalHoldCounter作用</h3><p>ThreadLocal的子类。每个线程用其与对象绑定，记录自己的重入次数。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个线程维护一个ThreadLocalMap类对象，以ThreadLocal对象为key，以变量副本为value。</p><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>ThreadLocalMap对ThreadLocal对象的引用是<strong>弱引用</strong>，如果没有外部强引用指向它，GC时就会回收这个ThreadLocal对象，key就变为null，对应的value无法被访问，如果线程不结束，value的引用一直存在。<br>针对这个问题，在调用get、set、remove时会对key为null的Entry进行清理。</p><h3 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>避免自身的内存泄漏。如果对ThreadLocalMap的key使用强引用，ThreadLocal对象永远不会被回收，如果使用弱引用，即使没有手动删除，当外部引用消失也会回收ThreadLocal对象。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>核心方法：acquire()和release()</p><h3 id="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗"><a href="#semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗" class="headerlink" title="semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?"></a>semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</h3><p>能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p><h3 id="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a>semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h3><p>能，原因是release会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>核心方法：await()和countdown()</p><h3 id="实现一个容器，提供两个方法，add，size-写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束"><a href="#实现一个容器，提供两个方法，add，size-写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束" class="headerlink" title="实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束"></a>实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</h3><p>使用wait()和notify()实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  必须先让t2先进行启动 使用wait 和 notify 进行相互通讯，wait会释放锁，notify不会释放锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> &#123;<br><br> <span class="hljs-keyword">volatile</span>   <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        list.add(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">T2</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T2</span>();<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 启动&quot;</span>);<br>                <span class="hljs-keyword">if</span>(t2.getSize() != <span class="hljs-number">5</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">/**会释放锁*/</span><br>                        lock.wait();<br>                        System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                lock.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>               System.out.println(<span class="hljs-string">&quot;t1 启动&quot;</span>);<br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>                   t2.add(i);<br>                   System.out.println(<span class="hljs-string">&quot;add&quot;</span>+i);<br>                   <span class="hljs-keyword">if</span>(t2.getSize() == <span class="hljs-number">5</span>)&#123;<br>                       <span class="hljs-comment">/**不会释放锁*/</span><br>                       lock.notify();<br>                       <span class="hljs-keyword">try</span> &#123;<br>                           lock.wait();<br>                       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                           e.printStackTrace();<br>                       &#125;<br>                   &#125;<br>               &#125;<br>           &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用CountDownLatch实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> &#123;<br><br>   <span class="hljs-keyword">volatile</span> <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        list.add(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T3</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T3</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;t2 start&quot;</span>);<br>           <span class="hljs-keyword">if</span>(t.getSize() != <span class="hljs-number">5</span>)&#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   countDownLatch.await();<br>                   System.out.println(<span class="hljs-string">&quot;t2 end&quot;</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;t1 start&quot;</span>);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;<br>               t.add(i);<br>               System.out.println(<span class="hljs-string">&quot;add&quot;</span>+ i);<br>               <span class="hljs-keyword">if</span>(t.getSize() == <span class="hljs-number">5</span>)&#123;<br>                   System.out.println(<span class="hljs-string">&quot;countdown is open&quot;</span>);<br>                   countDownLatch.countDown();<br>               &#125;<br>           &#125;<br>            System.out.println(<span class="hljs-string">&quot;t1 end&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="和CountDonwLatch对比"><a href="#和CountDonwLatch对比" class="headerlink" title="和CountDonwLatch对比"></a>和CountDonwLatch对比</h3><ul><li>CountDownLatch减计数，CyclicBarrier加计数。</li><li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li><li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基础</title>
    <link href="/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><img src="/2022/05/11/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="线程生命周期"><h3 id="创建线程有几种方式"><a href="#创建线程有几种方式" class="headerlink" title="创建线程有几种方式"></a>创建线程有几种方式</h3><ol><li>继承<strong>Thread类</strong>，并重写 <strong>run()</strong> 方法，创建子类对象，执行 <strong>start()</strong> 方法，不能返回结果。</li><li>实现<strong>Runnable接口</strong>，并实现 <strong>run()</strong> 方法，创建实现类对象并传入<strong>Thread类</strong>的构造函数，执行 <strong>start()</strong> 方法。</li><li>实现<strong>Callable接口</strong>， 并实现 <strong>call()</strong> 方法,创建实现类对象并传入<strong>FutureTask</strong>的构造方法，再将FutureTask对象传入Thread构造方法中，执行start()方法，并通过FutureTask的 <strong>get()</strong> 方法获取结果。</li><li>通过ThreadPoolExecutor线程池创建</li></ol><h3 id="什么是线程安全？如何实现线程安全？"><a href="#什么是线程安全？如何实现线程安全？" class="headerlink" title="什么是线程安全？如何实现线程安全？"></a>什么是线程安全？如何实现线程安全？</h3><p><strong>线程安全：</strong> 多个线程访问一个对象时，每个线程都能获得正确的结果。<br><strong>实现线程安全：</strong> </p><ol><li>互斥同步：通过<strong>synchronize</strong>、<strong>Reentrantlock</strong>等互斥锁</li><li>非互斥同步：通过CAS</li><li>Threadlocal</li><li>其他：工具类（如：信号量、CountdownLatch、CylierBatch等）、wait&#x2F;notify、join等通信机制、volatile等</li></ol><h3 id="start-方法是否可以重复执行"><a href="#start-方法是否可以重复执行" class="headerlink" title="start()方法是否可以重复执行"></a>start()方法是否可以重复执行</h3><p>不可以。线程内部会维持一个状态变量，调用一次start()后这个变量会随之改变，如果执行start()时变量不为0会抛出异常。</p><h3 id="可不可以不执行start-方法，直接执行run-方法"><a href="#可不可以不执行start-方法，直接执行run-方法" class="headerlink" title="可不可以不执行start()方法，直接执行run()方法"></a>可不可以不执行start()方法，直接执行run()方法</h3><p>不可以。调用start()方法会让线程启动并进入就绪状态，然后自动执行run()方法，直接执行run()方法会把run()方法当作一个普通方法执行。</p><h3 id="知道哪些锁"><a href="#知道哪些锁" class="headerlink" title="知道哪些锁"></a>知道哪些锁</h3><ol><li><strong>乐观锁</strong>和<strong>悲观锁</strong><br>悲观锁：认为使用数据时一定有别的线程同时修改数据，所以在获取数据前要先加锁。Synchronized和Lock的实现类<br>乐观锁：认为使用数据时没有其他线程修改数据，所以不会加锁，只是在更新数据时判断有无其他线程对数据进行修改，如果没有则更新数据。CAS</li><li><strong>自旋锁</strong>和<strong>适应性自旋锁</strong><br>自旋锁：如果同步资源的使用时间很短，没必要令等待线程进入阻塞状态（阻塞和唤醒需要耗费处理器时间），通过让线程自旋等待数据。原理是CAS<br>适应性自旋锁：根据之前的自旋次数和锁的持有状态自动调整自旋次数，避免自旋时间多长浪费cpu资源</li><li><strong>公平锁</strong>和<strong>非公平锁</strong><br>公平锁：如果前面有线程在申请资源，则排队等待锁的释放。<br>非公平锁：无论前面有没有线程等待，直接尝试获取锁，如果获取失败则排队等待。可能导致某些线程一直拿不到锁。</li><li><strong>可重入锁</strong>和<strong>不可重入锁</strong><br>可重入锁：同一个线程如果已经获得了外部方法的锁，再进入内层方法会自动获得锁（前提是锁是同一个对象），避免死循环</li><li><strong>排他锁</strong>和<strong>共享锁</strong><br>读读共享、其他都互斥</li></ol><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>参考链接：<a href="https://javaguide.cn/java/concurrent/jmm.html#%E4%BB%8E-cpu-%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%B4%E8%B5%B7">https://javaguide.cn/java/concurrent/jmm.html#%E4%BB%8E-cpu-%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%B4%E8%B5%B7</a></p><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>JMM是为了屏蔽不同操作系统内存模型差异提出的一组<strong>规范</strong>。JMM<strong>抽象了线程和内存之间的关系</strong>，同时<strong>规定了从源代码到CPU执行指令这个过程中要遵守的规则</strong>，目的是简化多线程编程。JMM主要围绕<strong>原子性、可见性、有序性</strong>。<br>JMM规定所有的变量都存在<strong>主内存</strong>中，同时每个线程都有一个<strong>本地内存</strong>存放共享变量的<strong>副本</strong>，所有修改都在本地内存中进行，每个线程只能访问自己的本地内存。</p><h3 id="什么是happens-before原则"><a href="#什么是happens-before原则" class="headerlink" title="什么是happens-before原则"></a>什么是happens-before原则</h3><p>happens-before原则描述两个操作之间的内存可见性。它是JMM底层规则的抽象总结，便于程序员理解，通过happens-before原则可以简单地判断线程安全。<br>定义：</p><ol><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li><li>如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li></ol><p>happens-before原则：</p><ol><li>程序顺序规则 ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li><li>解锁规则 ：对一个锁的解锁操作 Happens-Before于后续对这个锁的加锁操作；</li><li>volatile 变量规则 ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。</li><li>线程启动规则：Thread 对象的 start（）方法 happens-before 于此线程的每一个动作。</li><li>传递规则 ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li>线程终结规则：线程中的所有操作都先行发生于对此线程的终止检测；</li><li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li></ol><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="synchronized如何使用"><a href="#synchronized如何使用" class="headerlink" title="synchronized如何使用"></a>synchronized如何使用</h3><ol><li>修饰静态方法：获得类的锁，实际对Class对象加锁</li><li>修饰普通方法：获得对象的锁</li><li>修饰代码块：在括号里指定获得锁的对象</li></ol><h3 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h3><ol><li>修饰代码块：通过在字节码中对应代码块的前后加上<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，使锁的计数器加1或减1，同一时刻只有一个线程可以获得monitor监视器的持有权（每个对象有一个内置的monitor对象）。</li><li>修饰方法：在对应方法的字节码上加入<strong>ACC_SYNCHRONIZED</strong>标记，标明同步方法。</li></ol><h3 id="JDK1-6-之后对synchronized作了哪些优化"><a href="#JDK1-6-之后对synchronized作了哪些优化" class="headerlink" title="JDK1.6 之后对synchronized作了哪些优化"></a>JDK1.6 之后对synchronized作了哪些优化</h3><p><strong>锁粗化：</strong> 减少不必要的连续的锁，将连续的锁变为一个范围更大的锁<br><strong>锁消除：</strong> 通过<strong>逃逸分析</strong>判断如果对象不会被其他线程方法，则取消锁<br><strong>适应性自旋：</strong> 通过之前自旋次数和获得锁的情况调整自旋次数<br><strong>锁升级：</strong></p><ol><li>无锁  </li><li>偏向锁：对于获得一个线程，获得了某个对象的锁后，再访问该对象就不用重新获得锁了，如果有两个线程竞争锁，则升级为轻量级锁。对象头由<strong>线程ID</strong>、<strong>epoch</strong>、<strong>对象分代年龄</strong>、<strong>是否是偏向锁</strong>、<strong>锁标志位</strong>构成。</li><li>轻量级锁：使用CAS获取锁，没获取到锁的线程自旋等待，如果自旋次数超过阈值，则升级为重量级锁。在<strong>栈</strong>里加入一个<strong>锁记录</strong>，存放之前的对象头中的Markword内容，并将对象头中的Markword替换为<strong>指向栈中锁记录的指针</strong>。</li><li>重量级锁： 竞争锁失败直接进入阻塞状态。对象头中存放指向锁监视器的指针。</li></ol><h3 id="Synchronized实现可重入的原理"><a href="#Synchronized实现可重入的原理" class="headerlink" title="Synchronized实现可重入的原理"></a>Synchronized实现可重入的原理</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a>volatile作用</h3><ol><li>防止指令重排序，保证<strong>有序性</strong>  </li><li>保证变量<strong>可见性</strong></li></ol><h3 id="什么是指令重排序"><a href="#什么是指令重排序" class="headerlink" title="什么是指令重排序"></a>什么是指令重排序</h3><p>在执行程序时为了提高性能，编译器和处理器会对指令进行重排序。<br>编译重排序：在不改变单线程程序语义的条件下，调整指令顺序，提高效率。<br>处理器重排序：由于处理器并行执行指令出现指令的重排序</p><h3 id="as-if-serial原则"><a href="#as-if-serial原则" class="headerlink" title="as-if-serial原则"></a>as-if-serial原则</h3><p>无论怎么重排序，单线程程序的执行结果不能改变。</p><h3 id="防止指令重排序原理"><a href="#防止指令重排序原理" class="headerlink" title="防止指令重排序原理"></a>防止指令重排序原理</h3><p><strong>内存屏障。</strong> 内存屏障作用包括：1.禁止内存屏障前后的指令重排序；2.强制将变量写到主存，并使其他线程缓存中对应变量失效，强制到主存中读取。<br>写volatile变量时，JVM会在写之前插入<strong>storestore屏障</strong>，保证之前的写操作执行完毕，在写之后插入<strong>storeload屏障</strong>，保证写入对后面的读操作可见。<br>读volatile变量时，会在读后面插入<strong>loadload屏障</strong>和<strong>loadstore屏障</strong>，保证在后面的操作前已经读完。</p><h3 id="如何保证变量可见性"><a href="#如何保证变量可见性" class="headerlink" title="如何保证变量可见性"></a>如何保证变量可见性</h3><p>当写volatile变量时，在字节码前加上一个<strong>lock前缀</strong>（本质是内存屏障），将缓存数据写回主存，同时使其他cpu中该地址数据无效，其他线程读取变量时就需要到主存中读，这样读取到的就是最新值。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h3><ol><li>修饰类：声明该类不允许继承  </li><li>修饰方法：声明该方法不允许重写</li><li>修饰变量：变量初始化后不可改变</li><li>修饰参数：参数指向不可改变</li></ol><h3 id="final修饰的字段必须是编译期常量吗"><a href="#final修饰的字段必须是编译期常量吗" class="headerlink" title="final修饰的字段必须是编译期常量吗"></a>final修饰的字段必须是编译期常量吗</h3><p>不一定。只是初始化后不能再改变。</p><h3 id="final重排序规则"><a href="#final重排序规则" class="headerlink" title="final重排序规则"></a>final重排序规则</h3><p>基本数据类型：<br>　final写：禁止final写重排序到构造函数以外。<br>　final读：禁止初次读对象与读该对象的final成员变量重排序<br>引用数据类型：禁止　在构造函数对final修饰的成员域的写入　与　之后将这个被构造的对象赋值给引用变量　重排序</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/2022/05/01/SPI/"/>
    <url>/2022/05/01/SPI/</url>
    
    <content type="html"><![CDATA[<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><h3 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h3><p>在面向对象编程中，一般都是基于接口编程，在实现一个具体实例时，就需要指明具体的实现类，一旦需要换一种实现方式，就需要修改代码。为了实现模块装配时不用动态指明具体实现类，就需要一种<strong>为接口寻找服务实现</strong>的机制，SPI就是这样一种机制，核心思想是<strong>解耦</strong>。<br>SPI将服务接口和服务实现分离，实现服务调用方和服务提供方的解耦，能够提升程序的可扩展性和可维护性，修改和替换服务的实现都不需要修改调用方。<br>（跟SpringBoot的自动装配思想很像）</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li>调用者定义一个接口</li><li>服务提供者提供接口的一个具体实现，在其jar包的META-INF&#x2F;servies目录下创建一个以<mark>接口全限定名</mark>命名的文件，文件内容为<mark>实现类的全限定类名</mark></li><li>将接口实现类的jar包放在主程序的classpath中</li><li>主程序通过ServiceLoader.load(接口名.class)从自己和jar包中的META-INF&#x2F;services目录下找到对应的文件，并读取其中的全限定类名，通过反射构建实现类对象实例，保存到provider列表中。</li></ol><p>SPI降低了服务调用方和服务提供方的耦合度，假如某个需求变更了，只需要更换jar包即可更改实现，而不用对调用方进行修改。</p><h3 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h3><p><strong>SPI：</strong> </p><ol><li><mark>接口位于调用者的包里</mark>  </li><li>概念上更依赖调用方</li><li>实现位于独立的包中</li></ol><p><strong>API：</strong>  </p><ol><li><mark>接口位于实现方的包里</mark>  </li><li>概念上更接近实现方  </li><li>实现和接口在一个包里</li></ol><h3 id="SPI有哪些缺点"><a href="#SPI有哪些缺点" class="headerlink" title="SPI有哪些缺点"></a>SPI有哪些缺点</h3><ol><li>遍历加载所有实现类，效率较低</li><li>并发情况下，多个ServiceLoader同时load会有并发问题</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a><br><a href="https://zhuanlan.zhihu.com/p/376142459">https://zhuanlan.zhihu.com/p/376142459</a><br><a href="https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176">https://www.bilibili.com/video/BV1E44y1N7Nk?vd_source=68c0ccddba0b5998af7c2c8b31c1b176</a></p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2022/04/29/%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/04/29/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p><strong>Throwable</strong>是所有错误与异常的超类。<br>　<strong>Error：</strong> 程序无法处理的错误。<br>　<strong>Exception：</strong> 程序可以捕捉并处理的错误，分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。<br>　<strong>RuntimeException及其子类</strong>统称为<strong>非受检查异常</strong>，常见的有：  </p><ol><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误)</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>SecurityException （安全错误比如权限不够）</li></ol><p>　　</p><p>　其他异常都属于<strong>受检查异常</strong>，常见的有：</p><ol><li>IO 相关的异常</li><li>ClassNotFoundException </li><li>SQLException</li></ol><h3 id="finally中的代码一定会运行吗"><a href="#finally中的代码一定会运行吗" class="headerlink" title="finally中的代码一定会运行吗"></a>finally中的代码一定会运行吗</h3><p>不一定。<br>如果执行finally之前虚拟机终止，或者线程死亡都不会执行finally</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/04/28/%E9%9B%86%E5%90%88/"/>
    <url>/2022/04/28/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><img src="/2022/04/28/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png" class="" title="集合框架">  <h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List有哪些集合类"><a href="#List有哪些集合类" class="headerlink" title="List有哪些集合类"></a>List有哪些集合类</h3><ol><li>ArrayList: Object[]数组</li><li>LinkedList: 双向链表</li><li>vector: Object[]数组，线程安全</li><li>CopyOnWriteArrayList：JUC并发集合，线程安全</li></ol><h3 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h3><ol><li><strong>底层数据结构：</strong> ArrayList底层是<strong>Object数组</strong>，LinkedList底层是<strong>双向链表</strong></li><li><strong>随机访问：</strong> ArrayList支持<strong>随机访问</strong>，LinkedList只能遍历</li><li><strong>插入删除：</strong> ArrayList插入删除受元素位置影响，如果在末尾插入元素，时间复杂度O(1)，如果在中间插入或删除，时间复杂度O(n-i)，因为后续元素要移位；LinkedList在头尾插入或删除时间复杂度都是O(1)，在指定位置插入删除时间复杂度是O(n)，因为要遍历到指定位置</li><li><strong>内存占用：</strong> ArrayList空间浪费体现在会在数组末尾预留一定空间；LinkedList体现在每个元素比ArrayList占据更多空间（维护节点信息）</li></ol><h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h3><p>每次添加元素时会比较添加后的size和容量capacity的大小，如果超出容量则自动扩容，创建一个新数组，大小为旧数组大小的<strong>大约1.5倍</strong>，将旧数组元素拷贝到新数组中。<br>为减少数组多次扩容带来的性能影响，可以通过<strong>ensureCapacity()方法</strong>手动指定扩容大小，一次扩容完毕，避免多次扩容。<br><mark>（注：以无参构造方法创建ArrayList时，实际分配的是一个空数组，当第一次添加元素时触发扩容，扩容到容量为10）</mark></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map有哪些集合类"><a href="#Map有哪些集合类" class="headerlink" title="Map有哪些集合类"></a>Map有哪些集合类</h3><ol><li>HashMap: 1.7 数组+链表，1.8 数组+链表+红黑树</li><li>TreeMap: 红黑树，支持按key排序</li><li>HashTable: 数组+链表，线程安全</li><li>LinkedHashMap: 双向链表+哈希表，实现LRU</li><li>ConcurrentHashMap：JUC并发集合，线程安全</li><li>ConcurrentSkipListMap：JUC并发集合，支持排序，底层是跳表</li></ol><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ol><li><strong>线程安全：</strong> HashTable是<strong>线程安全</strong>的，HashMap线程不安全</li><li><strong>是否支持NULL数据：</strong> HashTable不支持NULL键和NULL值，HashMap支持，但NULL键最多有一个</li><li><strong>底层结构：</strong> HashTable底层是数组+链表，HashMap是数组+红黑树+链表</li><li><strong>扩容大小：</strong> HashTable容量默认初始大小是<strong>11</strong>，每次扩容大小是<strong>2n+1</strong>，HashMap容量默认初始大小是<strong>16</strong>，每次扩容大小是<strong>2n</strong>。如果指定初始大小，HashTable直接就是指定大小，HashMap会扩容为<strong>离其最近的2的n次幂大小</strong></li></ol><h3 id="HashMap底层结构"><a href="#HashMap底层结构" class="headerlink" title="HashMap底层结构"></a>HashMap底层结构</h3><p><strong>1.7：</strong> 数组+链表，通过<strong>头插法</strong>插入元素。<br><strong>1.8：</strong> 数组+链表+红黑树，通过<strong>尾插法</strong>插入元素，当链表长度大于阈值（默认为8），且当前数组的长度大于64（否则先扩容），就将链表转为红黑树，小于等于6就转回链表</p><h3 id="为什么链表转为红黑树的阈值是8"><a href="#为什么链表转为红黑树的阈值是8" class="headerlink" title="为什么链表转为红黑树的阈值是8"></a>为什么链表转为红黑树的阈值是8</h3><p>转成红黑树是为了提升查询效率，红黑树的查询时间复杂度是O(logn)。但红黑树节点要比Node节点占更多的内存，所以当链表长度比较短的时候，红黑树并不能带来特别大的性能提升，同时还占用了更多内存。<br>同时经过统计，通常情况下，链表长度能达到8的情况是非常少的，这种设置更多是为了防止用户自己实现了比较差的hash算法导致的链表过长。</p><h3 id="HashMap的长度为什么是2的n次幂"><a href="#HashMap的长度为什么是2的n次幂" class="headerlink" title="HashMap的长度为什么是2的n次幂"></a>HashMap的长度为什么是2的n次幂</h3><ol><li>当插入元素时，需要通过 <strong>hash % length</strong> 确定插入位置，如果长度是2的n次方，上述公式等价于 <strong>hash &amp; (length-1)</strong> ，使用&amp;运算更快  </li><li>数据迁移时判断更方便。当长度是2的n次方时，扩容时判断元素是否要迁移到新的桶中，只需要用元素的key的二进制值和旧容量作&amp;运算，然后判断高位是否是0，如果是0则留在当前桶中，否则迁移到新桶，新桶位置为<strong>当前位置+旧容量</strong>。</li></ol><h3 id="HashMap扩容原理"><a href="#HashMap扩容原理" class="headerlink" title="HashMap扩容原理"></a>HashMap扩容原理</h3><p>先通过几个if条件判断特殊情况：  </p><ol><li>如果当前容量大于0，则正常扩容</li><li>判断当前容量是否大于等于最大容量，如果大于，阈值设为Integer.MAX_VALUE</li><li>如果是第一次put，则按构造函数设置初始容量和阈值</li></ol><p>正式扩容：<br>用新的数组大小初始化数组，遍历数组，如果桶中只有一个元素，直接迁移；如果是红黑树，则拆分红黑树；如果是链表，将其拆分成两个链表，通过计算每个元素的 <strong>hash &amp; oldcap</strong>，判断其高位是0或1，分别插入到两个链表中，对于高位是0的元素，留在当前位置，高位是1的元素，迁移至 <strong>pos+oldcap</strong> 位置。</p><h3 id="HashMap为什么不安全"><a href="#HashMap为什么不安全" class="headerlink" title="HashMap为什么不安全"></a>HashMap为什么不安全</h3><p><strong>1.7：</strong> 并发扩容时存在<strong>死循环</strong>问题，并发put存在<strong>数据丢失</strong>问题<br><strong>死循环：</strong>  由于1.7插入使用<strong>头插法</strong>，可能出现线程A设置好当前节点和其next节点后挂起，线程B在这期间完成了迁移工作，此时之前的节点和next节点的位置发生了对调，线程A再以头插法迁移时，就会出现头尾相连，在get()时就会发生死循环。<br><strong>数据丢失：</strong> 1.7中put()方法先创建一个要插入的节点，在其构造函数中指定好next节点。假设线程A创建好节点后挂起，线程B创建新的节点并完成插入，线程A恢复后完成插入，就会覆盖线程B插入的节点，丢失数据。<br><strong>同时put和get可能会get到null：</strong> put后发生rehash，先创建2倍大小的新数组，赋值给table，此时get就会返回Null。或者rehash后原来的节点迁移到新的位置，此时get也找不到对应节点。</p><p><strong>1.8：</strong> 并发put存在<strong>数据覆盖</strong>问题<br>1.8通过在数据迁移时构建两个链表并使用尾插法避免了1.7中的死循环问题（即便两个线程同时工作，无非第二个线程重复一遍第一个线程的工作），但仍存在并发put时数据丢失的问题。</p><h3 id="1-8中就不存在死循环了吗"><a href="#1-8中就不存在死循环了吗" class="headerlink" title="1.8中就不存在死循环了吗"></a>1.8中就不存在死循环了吗</h3><p>也会发生死循环。主要发生在<strong>链表转成树或对树进行操作时</strong>。<br>可能原因主要是多线程下操作同一对象时，对象的内部属性出现不一致。</p><h3 id="HashMap有几种遍历方式"><a href="#HashMap有几种遍历方式" class="headerlink" title="HashMap有几种遍历方式"></a>HashMap有几种遍历方式</h3><p>参考链接：<a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set有哪些集合类"><a href="#Set有哪些集合类" class="headerlink" title="Set有哪些集合类"></a>Set有哪些集合类</h3><ol><li>HashSet: 哈希表（对HashMap的封装）</li><li>LinkedHashSet： 双向链表+哈希表，保证插入有序性</li><li>TreeSet: 红黑树，支持排序</li><li>CopyOnWriteArraySet：JUC并发集合，内部使用CopyOnWriteArrayList</li><li>ConcurrentSkipListSet：JUC并发集合</li></ol><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>先计算hashcode判断加入位置，如果没有重复元素则直接加入，如果有重复元素通过equals()判断是否真的相同，如果相同就拒绝加入。<br><mark>实际HashSet的add()方法只是简单调用了HashMap的put()方法，无论是否存在相同元素都会加入，只是会在add()方法的返回值处返回标记告诉我们插入前是否存在相同元素。</mark></p><h3 id="Comparable-和-Comparator的区别"><a href="#Comparable-和-Comparator的区别" class="headerlink" title="Comparable 和 Comparator的区别"></a>Comparable 和 Comparator的区别</h3><p>Comparable接口一般由对象去实现，重写其中的 <strong>compareTo()</strong> 方法，自定义对象的排序规则。<br>Comparator更接近于一个外部排序器，在集合的sort()中使用，在 <strong>compare()</strong> 方法中定义排序规则。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue有哪些集合类"><a href="#Queue有哪些集合类" class="headerlink" title="Queue有哪些集合类"></a>Queue有哪些集合类</h3><ol><li>PriorityQueue: 堆</li><li>LinkedList：实现了Queue和Deque</li><li>ArrayDeque: Deque的实现类，数组+双指针</li><li>ArrayBlockingQueue：JUC并发集合，数组实现的阻塞队列</li><li>LinkedBlockingQueue：JUC并发集合，链表实现的阻塞队列</li><li>ConcurrentLinkedQueue：JUC并发集合，非阻塞队列</li><li>PriorityBlockingQueue：JUC并发集合，PriorityQueue的线程安全版本</li></ol><h3 id="LinkedList和ArrayDeque的区别"><a href="#LinkedList和ArrayDeque的区别" class="headerlink" title="LinkedList和ArrayDeque的区别"></a>LinkedList和ArrayDeque的区别</h3><ol><li>ArrayDeque底层是<strong>数组+双指针</strong>，LinkedList是链表</li><li>ArrayDeque不支持NULL数据，LinkedList支持</li></ol><h3 id="fail-fast机制和fail-safe机制"><a href="#fail-fast机制和fail-safe机制" class="headerlink" title="fail fast机制和fail safe机制"></a>fail fast机制和fail safe机制</h3><p><strong>fail-fast:</strong> 用迭代器遍历一个集合时，如果遍历过程中对集合的结构进行了修改（增加、删除），则抛出并发修改异常。集合中有一个成员遍历modcount表示集合被修改次数，remove()和add()会修改这个值。迭代器有个成员变量expectedmodcount变量，初始值等于modcount，每次执行next()方法都会检查两个变量是否相等。<br>解决方法：</p><ul><li>使用普通for循环+remove(下标)，不用迭代器，跳过检查步骤。</li><li>使用Iterator.remove()，会修改expectedmodcount的值，使其等于modcount。</li></ul><p><strong>fail-safe:</strong> 并发集合类都是fail-safe。遍历时先复制原有集合内容，在拷贝的集合上遍历。<br>缺点：</p><ul><li>复制需要额外空间和时间开销</li><li>不能保证遍历最新内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/04/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/04/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？优缺点？"><a href="#什么是反射？优缺点？" class="headerlink" title="什么是反射？优缺点？"></a>什么是反射？优缺点？</h3><p>反射就是将类中的各个成分（<strong>成员变量、方法、构造方法</strong>）映射成一个个<strong>对象</strong>，动态对其操作。<br><strong>优点：</strong> 让代码更灵活，可以在运行时分析操作类。<br><strong>缺点：</strong> 增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><h3 id="如何获取class对象"><a href="#如何获取class对象" class="headerlink" title="如何获取class对象"></a>如何获取class对象</h3><ol><li>类名.class()</li><li>对象.getclass()</li><li>Class.forName(全限定类名)</li></ol><h3 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h3><ol><li>动态代理</li><li>注解</li></ol><h3 id="介绍一下代理模式"><a href="#介绍一下代理模式" class="headerlink" title="介绍一下代理模式"></a>介绍一下代理模式</h3><p><strong>静态代理：</strong>   </p><ol><li>定义一个接口及其实现类  </li><li>创建一个代理类并实现这个接口</li><li>将目标类注入代理类，并在代理类中调用目标方法并增强</li></ol><p><strong>动态代理：</strong>分为<strong>JDK动态代理</strong>和<strong>Cglib动态代理</strong><br>　<strong>JDK动态代理：</strong>   <mark>只能代理实现了接口的类。</mark><br>　代理步骤：  </p><ol><li>定义一个接口及其实现类  </li><li>自定义<strong>InvocationHandler</strong>接口并重写**invoke()**方法，在invoke()中会通过反射调用被代理类的方法并自定义一些处理逻辑  </li><li>通过Proxy类创建代理对象</li></ol><p>当我们通过Proxy类创建的代理对象调用一个方法时，这个方法就会转发到InvocationHandler接口的实现类的invoke()方法。</p><p>　<strong>CGLIB动态代理：</strong> <mark>通过生成一个被代理类的子类拦截方法，故不能代理final修饰的类。</mark><br>　代理步骤：  </p><ol><li>定义一个类  </li><li>自定义<strong>MethodInterceptor</strong>接口并重写**intercept()**方法，通过反射调用被代理类方法，并自定义处理逻辑</li><li>通过<strong>Enhancer类</strong>的**create()**方法创建代理对象</li></ol><h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol><li><strong>灵活性：</strong> <strong>静态代理</strong>中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。<strong>动态代理</strong>更加灵活，不需要为每一个目标类都生成一个代理类，有相同处理需求的目标类可以复用同一个代理类。</li><li><strong>JVM 层面：</strong> <strong>静态代理</strong>在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 而<strong>动态代理</strong>是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h3 id="为什么JDK动态代理只能基于接口实现，不能基于继承"><a href="#为什么JDK动态代理只能基于接口实现，不能基于继承" class="headerlink" title="为什么JDK动态代理只能基于接口实现，不能基于继承"></a>为什么JDK动态代理只能基于接口实现，不能基于继承</h3><p>JDK动态代理在创建代理对象时，默认继承了Proxy类，由于Java只能单继承，所以只能通过接口实现</p><h3 id="为什么需要实现接口"><a href="#为什么需要实现接口" class="headerlink" title="为什么需要实现接口"></a>为什么需要实现接口</h3><p>因为代理对象只有实现同一个接口才能获得同一个方法并重新实现，实现代理的功能，否则代理对象都没有目标方法。</p><h3 id="static方法和private方法可以被动态代理吗"><a href="#static方法和private方法可以被动态代理吗" class="headerlink" title="static方法和private方法可以被动态代理吗"></a>static方法和private方法可以被动态代理吗</h3><p>不可以。<br>无论JDK动态代理还是CGLIB代理，都需要重写或实现方法的。<br>在JDK代理中，需要实现接口中的方法实现代理，而接口中的static方法不允许子类重写，所以<strong>编译</strong>时就会报错。<br>而CGLIB代理中，需要重写目标类方法来调用intercept()方法，通过用目标类引用指向代理对象实现多态，实际调用代理类方法。但<strong>静态方法不支持多态</strong>，最终调用的还是目标类的静态方法，即<strong>通过CGLIB代理static方法不会报错但不走代理</strong>。</p><p>private方法不能被外部访问，故不能被动态代理。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/04/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/04/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型起到一个模板的作用。对于只有数据类型不同的代码，如果没有泛型，就要针对每种类型重载一个方法，通过泛型，可以直接复用同一个方法。<br>泛型的类型在使用时指定，由编译器进行类型检查，提升安全性。</p><h3 id="泛型使用方式"><a href="#泛型使用方式" class="headerlink" title="泛型使用方式"></a>泛型使用方式</h3><p>泛型类、泛型接口、泛型方法</p><h3 id="如何理解java中的泛型是伪泛型"><a href="#如何理解java中的泛型是伪泛型" class="headerlink" title="如何理解java中的泛型是伪泛型"></a>如何理解java中的泛型是伪泛型</h3><p>伪泛型指语法上支持泛型，但在编译阶段会进行<strong>类型擦除</strong>，将所有的泛型替换为具体类型。<br>类型擦除原则：如果类型参数没有限制，则替换为<strong>Object</strong>，存在上界时，如&lt;T extends Number&gt;则替换成<strong>Number</strong>，存在下界时如&lt;T super Number&gt;，则替换成<strong>Object</strong>。</p><h3 id="如何理解泛型的编译器检查"><a href="#如何理解泛型的编译器检查" class="headerlink" title="如何理解泛型的编译器检查"></a>如何理解泛型的编译器检查</h3><p>编译器会<strong>先检查类型</strong>，再进行<strong>类型擦除</strong>，再<strong>编译</strong>。<br>类型检查针对<strong>引用</strong>，而无关它真正引用的对象。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>        list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="如何理解泛型的多态？泛型的桥方法？"><a href="#如何理解泛型的多态？泛型的桥方法？" class="headerlink" title="如何理解泛型的多态？泛型的桥方法？"></a>如何理解泛型的多态？泛型的桥方法？</h3><p>当子类继承泛型父类时，可能只希望继承某一个具体类型的父类，于是重写了父类对应具体类型参数的父类方法，但由于<mark>类型擦除</mark>，父类再编译阶段会替换成Object类，父类方法类型也变成Object类型，导致子类方法和父类方法不一样，重写变成了重载。<br>针对这个问题，JVM会为子类自动生成一个<mark>桥方法</mark>，桥方法和父类方法一致，<mark>在桥方法内部，会调用子类中自己重写的方法，也就是说，实际覆盖父类的是桥方法。</mark><br>（注：子类中的桥方法和自己重写的方法同时存在，如果只有方法类型不同，是无法辨别的，该如何处理呢？针对这个问题，我们自己写的代码是无法通过编译的，但编译器为了实现泛型的多态允许自己这样做，然后交给虚拟机区分，虚拟机可以根据参数类型和返回类型确定一个方法。）</p><h3 id="为什么基本类型不能作为泛型"><a href="#为什么基本类型不能作为泛型" class="headerlink" title="为什么基本类型不能作为泛型"></a>为什么基本类型不能作为泛型</h3><p>类型擦除后原始类型会变为Object，但Object不能存基本类型</p><h3 id="为什么泛型不能实例化"><a href="#为什么泛型不能实例化" class="headerlink" title="为什么泛型不能实例化"></a>为什么泛型不能实例化</h3><p>因为在编译器没办法确定泛型参数化类型，也就找不到具体的类字节码文件，无法完成类加载。<br>（如果非要用泛型实例化可以通过反射实现）</p><h3 id="泛型类可以定义泛型类型的静态变量吗"><a href="#泛型类可以定义泛型类型的静态变量吗" class="headerlink" title="泛型类可以定义泛型类型的静态变量吗"></a>泛型类可以定义泛型类型的静态变量吗</h3><p>不可以。因为泛型类型要在定义对象时指定，而静态变量不需要使用对象来调用，创建静态变量时无法确定其类型。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/04/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）<br>浮点数：float（4字节）、double（8字节）<br>字符型：char（2字节）<br>布尔型：boolean（1字节）<br><mark>（注：使用long要在数字后面加上后缀L，否则当作int处理）</mark>  </p><h3 id="引用变量占几个字节"><a href="#引用变量占几个字节" class="headerlink" title="引用变量占几个字节"></a>引用变量占几个字节</h3><p>32位系统占4字节，64位系统占8字节</p><h3 id="基本类型和包装类区别"><a href="#基本类型和包装类区别" class="headerlink" title="基本类型和包装类区别"></a>基本类型和包装类区别</h3><ol><li><strong>成员变量</strong>包装类不赋值默认是null，基本类型不赋值默认是0  </li><li>包装类可以用作泛型，基本类型不可以  </li><li>作为<strong>局部变量</strong>的基本类型存在栈里，作为<strong>成员变量</strong>的基本类型存在堆里，包装类存在堆里（<strong>几乎</strong>所有对象都存在堆里）</li><li>基本类型占用空间更小</li></ol><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p> Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False<br> 如果没有超出范围，则复用已有缓存对象，否则创建新对象</p><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：将基本类型用它们对应的引用类型包装起来；<br>　　Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>拆箱：将包装类型转换为基本数据类型；<br>　　int n &#x3D; i 等价于 int n &#x3D; i.intValue()</p><h3 id="switch支持哪些类型"><a href="#switch支持哪些类型" class="headerlink" title="switch支持哪些类型"></a>switch支持哪些类型</h3><p>byte、short、int、char及各自包装类、枚举类型、String</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p><strong>重载：</strong> 存在与<strong>同一个类</strong>中，要求<mark>方法名<strong>相同</strong>，参数类型、个数、顺序<strong>至少有一个不同</strong></mark>。<mark>（注：仅有方法返回类型不同不算重载）</mark><br><strong>重写：</strong> 针对<strong>父类和子类</strong>，子类对父类中的方法重新实现。要求：  </p><ol><li>子类方法的<strong>访问权限</strong><mark>大于等于</mark>父类  </li><li>子类方法的<strong>返回类型</strong><mark>小于等于</mark>父类</li><li>子类方法的<strong>抛出异常</strong><mark>小于等于</mark>父类</li></ol><h3 id="接口和抽象类的共同点和区别"><a href="#接口和抽象类的共同点和区别" class="headerlink" title="接口和抽象类的共同点和区别"></a>接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong>  </p><ol><li>都不能被实例化  </li><li>都可以有抽象方法  </li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ol><p><strong>区别：</strong>  </p><ol><li>接口主要对类的行为进行约束，实现了某个接口就拥有了其行为；抽象类更强调所属关系  </li><li><strong>一个类可以实现多个接口，但只能继承一个类</strong>  </li><li>接口的成员变量只能是<strong>public static final</strong>类型，不能被修改且有初始值；抽象类的变量不限制，并且可在子类中重新定义和赋值</li></ol><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>浅拷贝：</strong> 在堆上创建一个新的对象，但如果对象的属性是引用类型，浅拷贝直接复制其引用地址，即<mark>拷贝对象和原对象共用同一个内部对象</mark><br><strong>深拷贝：</strong> 连同内部对象一同复制，即<mark>拷贝对象创建一个新的内部对象</mark></p><h3 id="Object类有哪些方法"><a href="#Object类有哪些方法" class="headerlink" title="Object类有哪些方法"></a>Object类有哪些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashcode的作用"><a href="#hashcode的作用" class="headerlink" title="hashcode的作用"></a>hashcode的作用</h3><p>快速确定对象在哈希表中的索引位置</p><h3 id="为什么重写equals-必须重写hashcode"><a href="#为什么重写equals-必须重写hashcode" class="headerlink" title="为什么重写equals()必须重写hashcode()"></a>为什么重写equals()必须重写hashcode()</h3><p>因为两个相等的对象，其hashcode也必须相等<br>如果重写了equals()而没有重写hashcode()：<br><strong>使用HashSet或HashMap：</strong> 插入对象时，会先判断是否有相同的hashcode，如果hashcode相同再用equals()比较两个对象是否相等，如果没有重写hashcode()，两个相同对象的hashcode不同，认为集合内没有重复对象，直接插入，此时就会导致集合内存在两个相同的对象</p><h3 id="String如何实现不可变"><a href="#String如何实现不可变" class="headerlink" title="String如何实现不可变"></a>String如何实现不可变</h3><ol><li>保存字符串的数组用<strong>private</strong>和<strong>final</strong>修饰，并且没有提供修改字符数组的方法  </li><li>String类用<strong>final</strong>修饰，不可继承，避免了子类破坏不可变性</li></ol><h3 id="字符串拼接用’-’的原理"><a href="#字符串拼接用’-’的原理" class="headerlink" title="字符串拼接用’+’的原理"></a>字符串拼接用’+’的原理</h3><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <strong>StringBuilder</strong> 调用 <strong>append()</strong> 方法实现的，拼接完成之后调用 <strong>toString()</strong> 得到一个 String 对象。<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>对于 String str3 &#x3D; “str” + “ing”; 编译器会给你优化成 String str3 &#x3D; “string”; 称为<strong>常量折叠</strong>。</p><h3 id="a-x3D-a-b-和-a-x3D-b有什么区别"><a href="#a-x3D-a-b-和-a-x3D-b有什么区别" class="headerlink" title="a&#x3D;a+b 和 a+&#x3D;b有什么区别"></a>a&#x3D;a+b 和 a+&#x3D;b有什么区别</h3><p>+&#x3D;会隐式的将计算结果转换为持有结果的类型。<br>在使用byte、short、int相加的时候，首先会将数据提升到int类型，然后再计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b; <span class="hljs-comment">// error : cannot convert from int to byte</span><br>b += a; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><mark>a+b操作会将a和b提升到int，所以将int类型赋值给byte就会报错</mark></p><h3 id="char变量能不能存汉字"><a href="#char变量能不能存汉字" class="headerlink" title="char变量能不能存汉字"></a>char变量能不能存汉字</h3><p>可以。Java中char采用Unicode编码集，占2个字节，一个汉字也是2字节，所以可以存储。</p><h3 id="静态方法和静态属性可以被继承和重写吗"><a href="#静态方法和静态属性可以被继承和重写吗" class="headerlink" title="静态方法和静态属性可以被继承和重写吗"></a>静态方法和静态属性可以被继承和重写吗</h3><p>可以被继承。在子类中会被 <strong>“隐藏”</strong>。<br>static方法不能被重写，即便写法上是重写，但是并不具备<strong>多态</strong>的含义。static方法是属于类的，不属于任何对象，即便具体对象所声明的引用对象调用了static方法，实际执行的也是<strong>引用对象类型对应的类里的方法</strong>。<br>因为多态是通过父类引用指向子类对象，调用重写方法时子类方法有更高的优先级，所以调用子类方法，但隐藏方法和属性不参与比较。</p><h3 id="Java为什么不支持多继承？如何实现多继承？"><a href="#Java为什么不支持多继承？如何实现多继承？" class="headerlink" title="Java为什么不支持多继承？如何实现多继承？"></a>Java为什么不支持多继承？如何实现多继承？</h3><p>防止一个类继承多个同名方法，无法识别。</p><p>实现多继承：</p><ul><li>多层继承；</li><li>内部类；</li><li>接口；</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
