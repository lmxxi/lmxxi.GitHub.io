<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/08/09/%E5%8F%8D%E5%B0%84-1/"/>
    <url>/2022/08/09/%E5%8F%8D%E5%B0%84-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2022/04/25/%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/04/25/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？优缺点？"><a href="#什么是反射？优缺点？" class="headerlink" title="什么是反射？优缺点？"></a>什么是反射？优缺点？</h3><p>反射就是将类中的各个成分（<strong>成员变量、方法、构造方法</strong>）映射成一个个<strong>对象</strong>，动态对其操作。<br><strong>优点：</strong> 让代码更灵活，可以在运行时分析操作类。<br><strong>缺点：</strong> 增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。</p><h3 id="如何获取class对象"><a href="#如何获取class对象" class="headerlink" title="如何获取class对象"></a>如何获取class对象</h3><ol><li>类名.class()</li><li>对象.getclass()</li><li>Class.forName(全限定类名)</li></ol><h3 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h3><ol><li>动态代理</li><li>注解</li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/04/25/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/04/25/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型起到一个模板的作用。对于只有数据类型不同的代码，如果没有泛型，就要针对每种类型重载一个方法，通过泛型，可以直接复用同一个方法。<br>泛型的类型在使用时指定，由编译器进行类型检查。</p><h3 id="泛型使用方式"><a href="#泛型使用方式" class="headerlink" title="泛型使用方式"></a>泛型使用方式</h3><p>泛型类、泛型接口、泛型方法</p><h3 id="如何理解java中的泛型是伪泛型"><a href="#如何理解java中的泛型是伪泛型" class="headerlink" title="如何理解java中的泛型是伪泛型"></a>如何理解java中的泛型是伪泛型</h3><p>伪泛型指语法上支持泛型，但在编译阶段会进行<strong>类型擦除</strong>，将所有的泛型替换为具体类型。<br>类型擦除原则：如果类型参数没有限制，则替换为<strong>Object</strong>，存在上界时，如&lt;T extends Number&gt;则替换成<strong>Number</strong>，存在下界时如&lt;T super Number&gt;，则替换成<strong>Object</strong>。</p><h3 id="如何理解泛型的编译器检查"><a href="#如何理解泛型的编译器检查" class="headerlink" title="如何理解泛型的编译器检查"></a>如何理解泛型的编译器检查</h3><p>编译器会<strong>先检查类型</strong>，再进行<strong>类型擦除</strong>，再<strong>编译</strong>。<br>类型检查针对<strong>引用</strong>，而无关它真正引用的对象。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>        list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="如何理解泛型的多态？泛型的桥方法？"><a href="#如何理解泛型的多态？泛型的桥方法？" class="headerlink" title="如何理解泛型的多态？泛型的桥方法？"></a>如何理解泛型的多态？泛型的桥方法？</h3><p>当子类继承泛型父类时，可能只希望继承某一个具体类型的父类，于是重写了父类对应具体类型参数的父类方法，但由于<mark>类型擦除</mark>，父类再编译阶段会替换成Object类，父类方法类型也变成Object类型，导致子类方法和父类方法不一样，重写变成了重载。<br>针对这个问题，JVM会为子类自动生成一个<mark>桥方法</mark>，桥方法和父类方法一致，<mark>在桥方法内部，会调用子类中自己重写的方法，也就是说，实际覆盖父类的是桥方法。</mark><br>（注：子类中的桥方法和自己重写的方法同时存在，如果只有方法类型不同，是无法辨别的，该如何处理呢？针对这个问题，我们自己写的代码是无法通过编译的，但编译器为了实现泛型的多态允许自己这样做，然后交给虚拟机区分，虚拟机可以根据参数类型和返回类型确定一个方法。）</p><h3 id="为什么基本类型不能作为泛型"><a href="#为什么基本类型不能作为泛型" class="headerlink" title="为什么基本类型不能作为泛型"></a>为什么基本类型不能作为泛型</h3><p>类型擦除后原始类型会变为Object，但Object不能存基本类型</p><h3 id="为什么泛型不能实例化"><a href="#为什么泛型不能实例化" class="headerlink" title="为什么泛型不能实例化"></a>为什么泛型不能实例化</h3><p>因为在编译器没办法确定泛型参数化类型，也就找不到具体的类字节码文件，无法完成类加载。<br>（如果非要用泛型实例化可以通过反射实现）</p><h3 id="泛型类可以定义泛型类型的静态变量吗"><a href="#泛型类可以定义泛型类型的静态变量吗" class="headerlink" title="泛型类可以定义泛型类型的静态变量吗"></a>泛型类可以定义泛型类型的静态变量吗</h3><p>不可以。因为泛型类型要在定义对象时指定，而静态变量不需要使用对象来调用，创建静态变量时无法确定其类型。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2022/04/23/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/23/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）<br>浮点数：float（4字节）、double（8字节）<br>字符型：char（2字节）<br>布尔型：boolean（1字节）<br><mark>（注：使用long要在数字后面加上后缀L，否则当作int处理）</mark>  </p><h3 id="基本类型和包装类区别"><a href="#基本类型和包装类区别" class="headerlink" title="基本类型和包装类区别"></a>基本类型和包装类区别</h3><ol><li><strong>成员变量</strong>包装类不赋值默认是null，基本类型不赋值默认是0  </li><li>包装类可以用作泛型，基本类型不可以  </li><li>作为<strong>局部变量</strong>的基本类型存在栈里，作为<strong>成员变量</strong>的基本类型存在堆里，包装类存在堆里（<strong>几乎</strong>所有对象都存在堆里）</li><li>基本类型占用空间更小</li></ol><h3 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h3><p> Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False<br> 如果没有超出范围，则复用已有缓存对象，否则创建新对象</p><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：将基本类型用它们对应的引用类型包装起来；<br>　　Integer i &#x3D; 10 等价于 Integer i &#x3D; Integer.valueOf(10)<br>拆箱：将包装类型转换为基本数据类型；<br>　　int n &#x3D; i 等价于 int n &#x3D; i.intValue()</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p><strong>重载：</strong> 存在与<strong>同一个类</strong>中，要求<mark>方法名<strong>相同</strong>，参数类型、个数、顺序<strong>至少有一个不同</strong></mark>。<mark>（注：仅有方法返回类型不同不算重载）</mark><br><strong>重写：</strong> 针对<strong>父类和子类</strong>，子类对父类中的方法重新实现。要求：  </p><ol><li>子类方法的<strong>访问权限</strong><mark>大于等于</mark>父类  </li><li>子类方法的<strong>返回类型</strong><mark>小于等于</mark>父类</li><li>子类方法的<strong>抛出异常</strong><mark>小于等于</mark>父类</li></ol><h3 id="接口和抽象类的共同点和区别"><a href="#接口和抽象类的共同点和区别" class="headerlink" title="接口和抽象类的共同点和区别"></a>接口和抽象类的共同点和区别</h3><p><strong>共同点：</strong>  </p><ol><li>都不能被实例化  </li><li>都可以有抽象方法  </li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）</li></ol><p><strong>区别：</strong>  </p><ol><li>接口主要对类的行为进行约束，实现了某个接口就拥有了其行为；抽象类更强调所属关系  </li><li><strong>一个类可以实现多个接口，但只能继承一个类</strong>  </li><li>接口的成员变量只能是<strong>public static final</strong>类型，不能被修改且有初始值；抽象类的变量不限制，并且可在子类中重新定义和赋值</li></ol><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>浅拷贝：</strong> 在堆上创建一个新的对象，但如果对象的属性是引用类型，浅拷贝直接复制其引用地址，即<mark>拷贝对象和原对象共用同一个内部对象</mark><br><strong>深拷贝：</strong> 连同内部对象一同复制，即<mark>拷贝对象创建一个新的内部对象</mark></p><h3 id="Object类有哪些方法"><a href="#Object类有哪些方法" class="headerlink" title="Object类有哪些方法"></a>Object类有哪些方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br><br></code></pre></td></tr></table></figure><h3 id="hashcode的作用"><a href="#hashcode的作用" class="headerlink" title="hashcode的作用"></a>hashcode的作用</h3><p>快速确定对象在哈希表中的索引位置</p><h3 id="为什么重写equals-必须重写hashcode"><a href="#为什么重写equals-必须重写hashcode" class="headerlink" title="为什么重写equals()必须重写hashcode()"></a>为什么重写equals()必须重写hashcode()</h3><p>因为两个相等的对象，其hashcode也必须相等<br>如果重写了equals()而没有重写hashcode()：<br><strong>使用HashSet或HashMap：</strong> 插入对象时，会先判断是否有相同的hashcode，如果hashcode相同再用equals()比较两个对象是否相等，如果没有重写hashcode()，两个相同对象的hashcode不同，认为集合内没有重复对象，直接插入，此时就会导致集合内存在两个相同的对象</p><h3 id="String如何实现不可变"><a href="#String如何实现不可变" class="headerlink" title="String如何实现不可变"></a>String如何实现不可变</h3><ol><li>保存字符串的数组用<strong>private</strong>和<strong>final</strong>修饰，并且没有提供修改字符数组的方法  </li><li>String类用<strong>final</strong>修饰，不可继承，避免了子类破坏不可变性</li></ol><h3 id="字符串拼接用’-’的原理"><a href="#字符串拼接用’-’的原理" class="headerlink" title="字符串拼接用’+’的原理"></a>字符串拼接用’+’的原理</h3><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <strong>StringBuilder</strong> 调用 <strong>append()</strong> 方法实现的，拼接完成之后调用 <strong>toString()</strong> 得到一个 String 对象。<br>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。<br>对于 String str3 &#x3D; “str” + “ing”; 编译器会给你优化成 String str3 &#x3D; “string”; 称为<strong>常量折叠</strong>。</p><h3 id="a-x3D-a-b-和-a-x3D-b有什么区别"><a href="#a-x3D-a-b-和-a-x3D-b有什么区别" class="headerlink" title="a&#x3D;a+b 和 a+&#x3D;b有什么区别"></a>a&#x3D;a+b 和 a+&#x3D;b有什么区别</h3><p>+&#x3D;会隐式的将计算结果转换为持有结果的类型。<br>在使用byte、short、int相加的时候，首先会将数据提升到int类型，然后再计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b; <span class="hljs-comment">// error : cannot convert from int to byte</span><br>b += a; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><mark>a+b操作会将a和b提升到int，所以将int类型赋值给byte就会报错</mark></p><h3 id="char变量能不能存汉字"><a href="#char变量能不能存汉字" class="headerlink" title="char变量能不能存汉字"></a>char变量能不能存汉字</h3><p>可以。Java中char采用Unicode编码集，占2个字节，一个汉字也是2字节，所以可以存储。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
